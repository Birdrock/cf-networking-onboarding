Stale Routes Reenactment

## Assumptions
- You have a CF deployed

## What
As was discussed in the http-route track, the GoRouter redirects traffic for a particular CF HTTP route to a Diego Cell IP and a high numbered (ephemeral) port. When one app is deleted or moved, another app may later use the same Diego Cell IP and port. Let's say that appA is at 10.0.1.2:12345, then appA is deleted. Immediately after appA is deleted, appB is pushed and is now at 10.0.1.2:12345, where appA used to be. Then before the NATs messages reach the GoRouter with the updated route information, a client hits the route for appA. Instead of hitting appA, the GoRouter sends the traffic to appB. Yikes! This is an example of misrouting due to "stale" routes. 

Let's set up a situation with stale routes manually and see how dangerous it is. Then in the next story we will look at how Route Integrity fixes this issue.

## How

1. Route Integrity is turned on by default with CF Deployment. Let's go back in time and see what happened before Route Integrity. Redeploy your CF with Route Integrity turned off, using [this opsfile](https://github.com/cloudfoundry/cf-deployment/pull/745).

1. Push appA with an HTTP route.

1. Push a different app, appB, that will respond differently than appA. Ensure there is an HTTP Route mapped to appB.

1. Make sure an instance of appA and appB are on the same Diego Cell. This can be achieved through scaling if it doesn't happen at first.

1. Curl appA. See that you get the expected result for appA.

1. In previous http-route stories, you learned that the route table on the GoRouter maps routes to particular Diego Cell IPs and ports. Then the GoRouter sends traffic to the Diego Cell IP and port, which is then  rerouted to an app's overlayIP and app port using iptables rules on the nat table. Change the iptables rules so that the Diego Cell port that maps to appA now, incorrectly, redirects traffic to appB. This will imitate route staleness. Go back to the http-route stories if you need help doing this.

1. Curl the route for appA. If there is more than one instance of appA you may need to curl it several times.

### Expected Result
Even though you curled the route for appA, because the routes for appA were "stale" you got back the information for appB.

## Questions

1. Why is this dangerous?
1. What is the implications for this on a shared production environment, like PWS?
1. What could cause routes to become stale? What could exacerbate this problem?
1. Before Route Integrity, what could app devs do to prevent stale routes from accidentally releasing their data?

L: route-integrity

---

Route Integrity Demonstration

## Assumptioms
- You have a CF deployed

## What

Now that we've seen the dangers of stale routes in the last story, let's explore Route Integrity and see how it solves this issue. Route Integrity is enabled by enforcing TLS (or mTLS) between the GoRouter and the apps it routes to.

Side Note: Confusingly, this feature is often called "Route Integrity" by engineers, but is called "(m)TLS to apps" or "encrypting traffic from the GoRouter to backends" in documentation. I will continue calling it Route Integrity, because it is more succinct and sounds cooler.

Route Integrity is implemented by  giving the GoRouter a CA certificate at deploy time. At runtime when an app container is created, Diego generates a certificate from the GoRouter CA for the app and puts it inside of the app container. The certificate has a unique subject alternative name (SAN) per app instance. Diego runs a sidecar Envoy inside of the app container, which intercepts all incoming traffic from the GoRouter and is able to terminate TLS before forwarding traffic onto the app. When the GoRouter checks the certificate from the envoy sidecar, GoRouter checks that the SAN matches the app instance that it is expecting to hit. This way GoRouter is able to make sure that appA.cf-app.com is *actually going to* appA and not misrouting to appB due to stale routes. 

All of this work means that traffic should never be miss routed and that the app developer does not need to do anything in order for the GoRouter to app traffic to be sent over TLS.

Let's set up the same experiment as the previous story and see that when we imitate route staleness, that you are no longer able to see the data from the incorrect app.

## How

1. Deploy your CF with Route Integrity enabled with TLS (not mTLS).

1. Push an app, appA with an HTTP route.

1. Push a different app, appB, that will respond differently than appA. Ensure there is an HTTP Route mapped to appB. Make sure an instance of appA and appB are on the same Diego Cell. You can achieve this by scaling appB, but make sure there is only 1 instance of appA. 

1. Curl appA. See that you get the expected result.

1. Change the iptables rules so that the Diego Cell port that maps to appA now, incorrectly, redirects traffic to appB. This will imitate route staleness.

1. In another terminal tail the gorouter.stdout.log.

1. Curl the route for appA.


### Expected Result

So Route Integrity doesn't actually prevent route staleness, but it *does* prevent leaking data from appB when you are trying to access appA.

When you curl appA, you should get a 503 status code.
```
$ curl appA.cf-app.com
503 Service Unavailable
```

In the GoRouter bosh logs you should see a line about pruning the bad route.

```
{"log_level":3,"timestamp":1554761639.745829,"message":"prune-failed-endpoint","source":"vcap.gorouter.registry","data":{"route-endpoint":{"ApplicationId":"bf1cdd21-ed5b-429b-93ef-f74a4aadc55f","Addr":"10.0.1.13:61010","Tags":{"component":"route-emitter"},"RouteServiceUrl":""}}}

{"log_level":3,"timestamp":1554761639.7473993,"message":"backend-endpoint-failed","source":"vcap.gorouter","data":{"route-endpoint":{"ApplicationId":"bf1cdd21-ed5b-429b-93ef-f74a4aadc55f","Addr":"10.0.1.13:61010","Tags":{"component":"route-emitter"},"RouteServiceUrl":""},"error":"x509: certificate is valid for 0c2ca10a-0c19-4288-68e8-8d1f, not e5fdb45c-1b41-4602-45ac-b49e","attempt":1,"vcap_request_id":"3673ccd9-44ee-4d81-4a45-0ea75a96121c"}}
```

## Look at the code

GoRouter analyses different types of errors from the backend. In the case of misrouting, we are running into this [HostnameMismatch error](https://github.com/cloudfoundry/gorouter/blob/master/proxy/fails/basic_classifiers.go#L44-L51).

Depending on the type of error, GoRouter may choose to retry or not. Look at these [failure classifiers](https://github.com/cloudfoundry/gorouter/blob/master/proxy/fails/classifier_group.go#L5-L17). Are HostnameMismatch errors retried?

## Questions
1. If you had multiple instances of appA what do think would've happened? Try it out. Were you correct?
1. Route Integrity was introduced to fix misrouting due to route staleness. What other benefits does Route Integrity provide?
1. Keep hitting the HTTP route for appA several times over 1 minute. Sometimes you get a 503 and sometimes you get a 404. Why?

## Links
[CF Docs - TLS to Apps](https://docs.cloudfoundry.org/concepts/http-routing.html#tls-to-back-end)


L: route-integrity

---

[RELEASE] Route Integrity â‡§
L: route-integrity
