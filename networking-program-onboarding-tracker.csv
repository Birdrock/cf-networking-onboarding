Title,Type,Description,Labels,Task,Task,Task,Task,Task,Task,Task
Networking Program Onboarding Week [a note for facilitators],feature,"Hi there, facilitators!

This is a reminder to read the **[facilitation documentation](FACILITATION.md)** on GitHub.

It's also a short task list of things you might want to do before Onboarding Week starts. After you've completed the tasks you need to, remove this chore from the backlog. (I cannot make it self-destruct. Sad!)

üôè _If this story needs to be updated: please, please, PLEASE submit a PR. Amelia will be eternally grateful. How? Go to [this repo](https://github.com/pivotal/cf-networking-program-onboarding). Search for the phrase you want to edit. Make the fix!_",introduction,Allocate participants for the week.,Designate workstation(s).,"Get one ""floater"" laptop per pair to facilitate independent docs reading.",Create and populate private Tracker Project(s). Invite participants.,Add morning standup to participant calendars so they know where to be Monday morning.,Schedule boxes and lines whiteboarding sessions,Add Retro to participant calendars (ideally EOD Fri)
Introduction to the Networking Program Onboarding,feature,"WELCOME!

### What?
Networking Onboarding Week is a self-paced, guided exploration of the Cloud Foundry Networking Program components, embarked upon with other Cloud Foundry members. What we hope you get out of it:

1. A coherent, if cursory, overview of a complicated product.
1. Empathy for the customer who uses that product.
1. Knowledge of the breadth of work that the networking program does
1. Knowledge of how to debug networking components when things don't go as planned
1. Experience teaching. Unless you joined Pivotal at the same time as your pair and have been arm-in-arm ever since, you have different backgrounds. Moreover, you each have something valuable to offer to the other. Make sure you share it.

### How?
1. Take your time.
1. Be conscious of your pair's progress. Check in frequently to make sure you're both getting the most out of the material.
1. Read each story completely. You'll feel very silly if you struggle for hours with a problem that turns out to have been addressed in plain English....in a part of the story that you skipped.
1. If something in a story is missing / is wrong / could be improved, create an issue or a PR in the **[networking onboarding repo](https://github.com/pivotal/cf-networking-program-onboarding)**.
1. Seriously, take your time. How often are you paid just to learn?

**Pro Tip:** As you begin stories, click the ""Start"" button. If you feel confident about their content when you finish, click ""Finish"", ""Deliver"", and ""Accept"". If you still have questions on the material, leave it in the delivered state (i.e. with the ""Accept""/""Reject"" buttons showing) and decide at the end how you would like to follow up on your questions.

üôè _If this story needs to be updated: please, please, PLEASE submit a PR. Amelia will be eternally grateful. How? Go to [this repo](https://github.com/pivotal/cf-networking-program-onboarding). Search for the phrase you want to edit. Make the fix!_",introduction
How to Read Onboarding Stories,feature,"### Rules

1. Read all of the words in the story.
1. No really, read all the words.
1. When possible, I will tell you how to name things. For example, push an app and name is appA. That app will be referred to as appA for the rest of the story.
1. When I cannot tell you how to name things, because they are out of my control, they will be in **CAPS_WITH_UNDERSCORES**. For example, when you create routes. Routes contain a domain name that depends on your environment. I cannot control this, so I will refer to that route as APPA_ROUTE, or something similar.
1. Resources listed at the bottom of the stories are there if you get stuck or if you are interested in going deeper. You are not expected to read, or even open, every resource. However you are expected to...
1. ...read the whole story. Please.

### Emoji Key

- üìù indicates a story or set of instructions where the commands will be provided to you. Lots of copying and pasting.
- ü§î indicates a story or set of instructions where the commands will NOT be provided to you. Previous stories should set up for success for these exercises. More thinking and digging through docs for these.
- ‚ùìThis indicates a non-rhetorical question. I really want you to think about the question. Discuss the answer with your pair and *record an answer in the comments of the story*. We will go over the questions and answers during the next standup.

üôè _If this story needs to be updated: please, please, PLEASE submit a PR. Amelia will be eternally grateful. How? Go to [this repo](https://github.com/pivotal/cf-networking-program-onboarding). Search for the phrase you want to edit. Make the fix!_",introduction,Read this story closely
Set Up Your Environment,feature,"## How
1. Grab a Networking OSS dev environment that is relatively up-to-date. You will be using this environment for the whole week.

1. Create and target an org and space where you will be doing all of your work. if you are working on a Networking Team machine, you hould have the script `cf_seed` in your workstation to do this for you. You can find this script [here](https://github.com/cloudfoundry/networking-workspace/blob/0925ac5f6d1ca214e2dd871a6e36662fbd8a74b3/shared.bash#L184-L188).

üôè _If this story needs to be updated: please, please, PLEASE submit a PR. Amelia will be eternally grateful. How? Go to [this repo](https://github.com/pivotal/cf-networking-program-onboarding). Search for the phrase you want to edit. Make the fix!_",introduction
Meet Proxy!,feature,"## Assumption

- You have a CF deployed

## What

In these onboarding stories you will be using the proxy app a lot. Basically every story, so let's get familiar with it. Proxy is little golang app that is surprisingly powerful. In this story we are going to test out some of its functions.

Often with container to container (c2c) networking stories, you need an app to make a request to another app. Or you want to time how long DNS resolution (turning a URL into an IP address) is taking. You could do this with `cf ssh` and then running `curl` or `dig` (and we will in later stories!), but the proxy app was created so we didn't have to do that. It has different endpoints that will ...proxy... traffic to a given destination and that will do DNS resolution of a URL you give it, among other things.
Using proxy gives a better mirror how users use our product.

Let's check out proxy's power.

## How

üìù **Push a proxy app**

1. Clone the [cf-networking-release repo](https://github.com/cloudfoundry/cf-networking-release)
   ```
git clone https://github.com/cloudfoundry/cf-networking-release
   ```
1. Go to the proxy app
   ```
cd ~/workspace/cf-networking-release/src/example-apps/proxy
   ```
1. Push the app and name it appA
 ```
cf push appA
 ```

ü§î **Use the proxy app**

Check out the [docs](https://github.com/cloudfoundry/cf-networking-release/blob/develop/src/example-apps/proxy/README.md) for the proxy app to find all the endpoints.
If you want to see how the endpoints are implemented, go to [the code](https://github.com/cloudfoundry/cf-networking-release/blob/develop/src/example-apps/proxy/main.go#L14-L26).

When you push an app, an HTTP route is automatically created. Let's call this route PROXY_ROUTE.

1. Use the `/dig/URL_TO_DIG` endpoint to do DNS resolution for google.com.
1. Use the `/digudp/URL_TO_DIG` endpoint to do a DNS resolution  for google.com over udp. Dig usually uses tcp. This is a great way to test if udp traffic is working. (What are tcp and udp? Check out the resource below!)
1. Use the `/proxy/URL` endpoint to send traffic to neopets.com.
1. Use at least two more endpoints.

### Expected Outcome

Now you know the power of proxy!

## Resources
[tcp vs udp](https://www.vpnmentor.com/blog/tcp-vs-udp/)

üôè _If this story needs to be updated: please, please, PLEASE submit a PR. Amelia will be eternally grateful. How? Go to [this repo](https://github.com/pivotal/cf-networking-program-onboarding). Search for the phrase you want to edit. Make the fix!_",introduction
East/West What? Directional Networking Terms,feature,"## What

Network traffic can go in many directions, and there are many jargony ways to refer to them. Let's define them.

**Ingress Traffic** is traffic that originates outside the local network that is transmitted to somewhere inside the local network. Remember ingress traffic is coming *in*.

**Egress Traffic** is traffic that originates inside the local network that is transmitted somewhere outside of the local network. Remember egress traffic is *e*xiting the local network.

```
 INGRESS TRAFFIC EXAMPLE          EGRESS TRAFFIC EXAMPLE

         +-----+                          +-----+
         |     |                          |     |
     +---+     +------+               +---+     +------+
   +-+                |             +-+                |
 +-+   The Internet   ++          +-+   The Internet   ++
 |                   +-+          |                   +-+
 +-------------------+            +-------------------+

               V                                ^
               |                                ^
               |                                |
+----------------------+         +----------------------+
| Container    |       |         | Container    |       |
|              |       |         |              |       |
| +-------+    |       |         | +-------+    |       |
| |       |    |       |         | |       |    |       |
| | MyApp | <--+       |         | | MyApp | >--+       |
| |       |            |         | |       |            |
| +-------+            |         | +-------+            |
+----------------------+         +----------------------+

```

**North/South** traffic is any communication between two different networks.  Both Ingress and Egress are examples of North/South traffic.

**East/West** traffic is any communication within one network.

```
                  EAST/WEST TRAFFIC EXAMPLE

+-------------------------------------------------------------+
| My Local Network                                            |
|                                                             |
|                                                             |
|                                                             |
| +----------------------+         +----------------------+   |
| | Container1           |         | Container2           |   |
| |                      |         |                      |   |
| | +-------+            |         | +-------+            |   |
| | |       |            |         | |       |            |   |
| | | MyApp | +----------------->  | | MyApp |            |   |
| | |   1   |            |         | |   2   |            |   |
| | +-------+            |         | +-------+            |   |
| +----------------------+         +----------------------+   |
|                                                             |
+-------------------------------------------------------------+

```

## Questions

‚ùìHow would you use ingress, egress, north/south, and east/west to describe the following situations:
- You visit neopets in your browser.
- Your pair ssh-es onto your computer.
- You set up a local netcat server and send traffic to it from your terminal.

üôè _If this story needs to be updated: please, please, PLEASE submit a PR. Amelia will be eternally grateful. How? Go to [this repo](https://github.com/pivotal/cf-networking-program-onboarding). Search for the phrase you want to edit. Make the fix!_","introduction,questions"
Introduction ‚áß,release,,introduction
User Workflow: HTTP Routes,feature,"## Assumptions
- You have a CF deployed
- You have two [proxy](https://github.com/cloudfoundry/cf-networking-release/tree/develop/src/example-apps/proxy) apps pushed, named appA and appB

## What?

**Routes** are the URLs that can be used to access CF apps.
**Route Mappings** are the join table between routes (URLs) and the apps they send traffic to. Apps can have many routes.
And routes can send traffic to many apps. So Route Mappings is a many-to-many mapping.

## How?

üìù **Create a route that maps to two apps**
0. By default `cf push` creates a route. Look at all of the routes for all of your apps.
 ```
 cf apps
 ```
0. Use curl to hit appA.
 ```
 curl APP_A_URL
 ```
 It should respond with something like `{""ListenAddresses"":[""127.0.0.1"",""10.255.116.44""],""Port"":8080}`
 We'll get into the listen addresses later, but for now the most important thing to know is that the 10.255.X.X address is the overlay IP address. This IP is unique per app instance.
0. Create your own route (`cf map-route --help`) and map it to both appA **AND** appB.
0. Curl your new route over and over again `watch ""curl -sS MY-NEW-ROUTE`"".

### Expected Result
You have a route that maps to both appA and appB. See that the overlay IP changes, showing that you are routed evenly(ish) between all the apps mapped to the routes.

üôè _If this story needs to be updated: please, please, PLEASE submit a PR. Amelia will be eternally grateful. How? Go to [this repo](https://github.com/pivotal/cf-networking-program-onboarding). Search for the phrase you want to edit. Make the fix!_","http-routes,user-workflow"
Route Propagation - Part 0.1 - Creating a Route Overview,feature,"## What
In the previous story you used the CF CLI to create and map routes. But what happens under the hood to make all of this work? (hint: iptables is involved)
There are two main data flows for routes, (1) when an app dev pushes a new app with a route and (2) when an internet user connects to an app using the route.

Let's focus on the first case. Here is what happens under the hood:

Each step marked with a ‚ú® will be explained in more detail in a story in this track.
**When an app dev pushes a new app with a route**
1. ‚ú® The app dev pushes an app with a route using CAPI.
1. CAPI sends this information to Diego.
1. Diego schedules the container create on a specific Diego Cell.
1. Garden creates the container for your app.
1. ‚ú® Diego deploys an envoy sidecar inside of the app container, which will proxy traffic to your app.
1. ‚ú® When the container is being set up, iptables rules are created on the Diego Cell to send traffic that is intended for the app to the envoy sidecar.
1. ‚ú® When the app is created, Diego sends the route information to the Route Emitter. The Route Emitter sends the route information to GoRouter via NATS.
1. ‚ú® The GoRouter keeps a mapping of routes -> ip:ports in a routes table, which is consulted when someone curls the route.

## How
The following stories will look at how many components (CAPI, Diego BBS, Route Emitter, Nats, GoRouter, DNAT Rules, Envoy) work together to make routes work.

0. ü§î Step through steps above and follow along on [the HTTP Routing section of this diagram](https://miro.com/app/board/o9J_kyWPVPM=/?moveToWidget=3074457346471397934&cot=14).

### Expected Result
You can talk about route propagation at a high level.

## Logistics
In the next few stories, you are going to need to remember values from one story to another, there will be a space provided at the bottom of each story for your to record these values so you can store them.
It can be annoying to scroll up and down in the story as you use the values, so it could be helpful to store these values in a doc outside of tracker.

## Resources for the entire route propagation track
**Capi**
[CAPI API docs](https://apidocs.cloudfoundry.org/7.8.0/)
[CAPI V3 API docs](http://v3-apidocs.cloudfoundry.org/version/3.70.0/index.html)

**Diego**
[cfdot docs](https://github.com/cloudfoundry/cfdot)
[diego design notes](https://github.com/cloudfoundry/diego-design-notes#what-are-all-these-repos-and-what-do-they-do)
[diego bbs API docs](https://github.com/cloudfoundry/bbs/tree/master/doc)

**NATs**
[NATS message bus repo](https://github.com/nats-io/gnatsd)
[NATS ruby gem repo](https://github.com/nats-io/ruby-nats)

**GoRouter**
[GoRouter routing table docs](https://github.com/cloudfoundry/gorouter#the-routing-table)
[Detailed Diagram of several Route Related User Flows](https://realtimeboard.com/app/board/o9J_kyWPVPM=/)

**Iptables**
[iptables man page](http://ipset.netfilter.org/iptables.man.html)
[Aidan's iptables in CF ppt](https://docs.google.com/presentation/d/1qLkNu633yLHP5_S_OqOIIBETJpW3erk2QuGSVo71_oY/edit#slide=id.p)

**Route Integrity**
[Route Integrity/Misrouting Docs](https://docs.cloudfoundry.org/concepts/http-routing.html#-preventing-misrouting)

**Envoy**
[What is Envoy?](https://www.envoyproxy.io/docs/envoy/latest/intro/what_is_envoy)

üôè _If this story needs to be updated: please, please, PLEASE submit a PR. Amelia will be eternally grateful. How? Go to [this repo](https://github.com/pivotal/cf-networking-program-onboarding). Search for the phrase you want to edit. Make the fix!_",http-routes
Route Propagation - Part 0.2 - HTTP Traffic Overview,feature,"## What
In the previous story you went over the first of two main data flows for routes:
(1) when an app dev pushes a new app with a route and (2) when an internet user connects to an app using the route.

Here is what happens under the hood for the second case:

Each step marked with a ‚ú® will be explained in more detail in a story in this track.
**When an internet user sends traffic to your app**
1. The user visits your route in the browser or curls it via the command line.
1. The traffic first hits a load balancer in front of the CF Foundation.
1. The load balancer sends it to one of the GoRouters.
1. ‚ú® The GoRouter consults the route table and sends it to the listed IP and port. If Route Integrity is enabled, it sends this traffic via TLS.
1. ‚ú® The traffic makes its way to the correct Diego Cell, where it hits iptables DNAT rules that reroutes the traffic to the sidecar envoy for the app.
1. ‚ú® The Envoy terminates the TLS from the GoRouter and then sends the traffic on to the app.

## How
The following stories will look at how many components (CAPI, Diego BBS, Route Emitter, Nats, GoRouter, DNAT Rules, Envoy) work together to make routes work.

0. ü§î Step through steps above and follow along on [the HTTP Routing section of this diagram](https://realtimeboard.com/app/board/o9J_kyWPVPM=/)

### Expected Result
You can talk about HTTP network traffic flow with fellow CF engineers.

## Logistics
In the next few stories, you are going to need to remember values from one story to another, there will be a space provided at the bottom of each story for your to record these values so you can store them.

## Resources for the entire route propagation track
**Capi**
[CAPI API docs](https://apidocs.cloudfoundry.org/7.8.0/)
[CAPI V3 API docs](http://v3-apidocs.cloudfoundry.org/version/3.70.0/index.html)

**Diego**
[cfdot docs](https://github.com/cloudfoundry/cfdot)
[diego design notes](https://github.com/cloudfoundry/diego-design-notes#what-are-all-these-repos-and-what-do-they-do)
[diego bbs API docs](https://github.com/cloudfoundry/bbs/tree/master/doc)

**NATs**
[NATS message bus repo](https://github.com/nats-io/gnatsd)
[NATS ruby gem repo](https://github.com/nats-io/ruby-nats)

**GoRouter**
[GoRouter routing table docs](https://github.com/cloudfoundry/gorouter#the-routing-table)
[Detailed Diagram of several Route Related User Flows](https://realtimeboard.com/app/board/o9J_kyWPVPM=/)

**Iptables**
[iptables man page](http://ipset.netfilter.org/iptables.man.html)
[Aidan's iptables in CF ppt](https://docs.google.com/presentation/d/1qLkNu633yLHP5_S_OqOIIBETJpW3erk2QuGSVo71_oY/edit#slide=id.p)

**Route Integrity**
[Route Integrity/Misrouting Docs](https://docs.cloudfoundry.org/concepts/http-routing.html#-preventing-misrouting)

**Envoy**
[What is Envoy?](https://www.envoyproxy.io/docs/envoy/latest/intro/what_is_envoy)

üôè _If this story needs to be updated: please, please, PLEASE submit a PR. Amelia will be eternally grateful. How? Go to [this repo](https://github.com/pivotal/cf-networking-program-onboarding). Search for the phrase you want to edit. Make the fix!_",http-routes
Route Propagation - Part 1 - CAPI,feature,"## Assumptions
- You have a OSS CF deployed
- You have one [proxy](https://github.com/cloudfoundry/cf-networking-release/tree/develop/src/example-apps/proxy) app pushed and called appA
- I recommend deleting all other apps

## What
The Cloud Controller API (CAPI) maintains the database of all apps, domains, routes, and route mappings.
However CAPI does not keep track of *where* those apps are deployed. Nor does CAPI track the IPs and ports each
route should, well, *route* to. That's the job of the router, often called GoRouter.

CAPI keeps track of the desired state. The user wants a route called MY_ROUTE that sends traffic to appA.
But the user doesn't (shouldn't) care about the logistics needed to make that route happen. That is the responsibility of other components.

Let's look at what information CAPI *does* keep track of.

## How

0. ü§î Map a route to appA. Let's call this route APP_A_ROUTE. I recommend _deleting_ all other routes.

0. ü§î Look at the domains, routes, route mappings, and apps in CAPI's database.
    To look at all the domains you can curl CAPI using `cf curl /v2/domains`. Use the [CAPI docs](https://apidocs.cloudfoundry.org/7.8.0/) to figure out the APIs for the other resources.

This is all of the information that CAPI contains about routes. Note there are no IPs anywhere. Note that all of these routes are for CF apps, none of them are for CF components.

### Expected Result
You can view data from CAPI about the route APP_A_ROUTE that you created.

## Recorded Values
Record the following values that you generated or discovered during this story.
```
APP_A_ROUTE=<value>
```

## Resources
[CAPI API docs](https://apidocs.cloudfoundry.org/7.8.0/)

üôè _If this story needs to be updated: please, please, PLEASE submit a PR. Amelia will be eternally grateful. How? Go to [this repo](https://github.com/pivotal/cf-networking-program-onboarding). Search for the phrase you want to edit. Make the fix!_",http-routes
Route Propagation - Part 2 - Diego BBS,feature,"## Assumptions
- You have a OSS CF deployed
- You have one [proxy](https://github.com/cloudfoundry/cf-networking-release/tree/develop/src/example-apps/proxy) app pushed and called appA
- You have one route mapped to appA called APP_A_ROUTE
- You have completed the previous stories in this track

## What

**Diego** is an umbrella term for many components that work together to make CF container orchestration happen. These components are maintained by the Diego team.

**BBS** stands for Bulletin Board System. This is the database that the Diego components use to keep track of DesiredLRPs and ActualLRPs.

**LRPs**, or Long Running Processes, represent work that a client (ie CAPI) wants Diego to keep running indefinitely. Apps are the primary example of LRPs. Diego will try to
keep them running as best it can. When an app stops or fails, it will attempt to restart it and keep it running.

**Desired LRPs** represent what a client (ie CAPI) wants ""the world"" to look like (for example, how many instances of which apps). They contain no information
about where LRPs should be run, because the user shouldn't care.

**Actual LRPs** represent what Diego is currently *actually* running. Actual LRPs contain information about which Diego Cell the LRP is running on and which port maps to the LRP.

For this story, let's look at the data stored in the BBS and see what information it has about appA. Diego will go on to send this information via the Route Emitter to GoRouter, so GoRouter knows where to send network traffic to.

## How

üìù **Look at actualLRPS**
0. Grab the guid for appA. You'll need it in a moment. Let's call it APP_A_GUID.
 ```
 cf app appA --guid
 ```
0. Ssh onto the Diego Cell vm where appA is running and become root.
0. Use the [cfdot CLI](https://github.com/cloudfoundry/cfdot) to query BBS for actualLRPs. Cfdot is a helpful CLI for using the BBS API.
 It's a great tool for debugging on the Diego Cell.
 ```
 cfdot actual-lrps | jq .
 ```
0. Search through the actual LRPs for APP_A_GUID. It should match the beginning of a process guid. You'll find an entry for each instance of appA that is running.
0. Let's dissect and store the most important information (for us) about appA:
   ```
   {
     ""process_guid"": ""ab2bd185-9d9a-4628-9cd8-626649ec5432-cb50adac-6861-4f03-92e4-9fcc1a204a1e"",
     ""index"": 0,
     ""cell_id"": ""d8d4f5fe-36f2-4f50-8c4a-8df293f6bc5b"",
     ""address"": ""10.0.1.12"",                  <------ The cell's IP address where this app instance is running, also sometimes called the host IP. Let's call this DIEGO_CELL_IP.
       ""ports"": [
         {
           ""container_port"": 8080,            <------ The port the app is listening on inside of its container. 8080 is the default value. Let's call this CONTAINER_APP_PORT.
           ""host_port"": 61012,                <------ The port on the Diego Cell where traffic to your app is sent to before it is forwarded to the overlay address and the container_port. Let's call this DIEGO_CELL_APP_PORT.
           ""container_tls_proxy_port"": 61001, <------ The port inside of the app container that envoy is listening on for HTTPS traffic. This is the default value (currently unchangeable). Let's call this CONTAINER_ENVOY_PORT.
           ""host_tls_proxy_port"": 61014,      <------ The port on the Diego Cell where traffic to your app's envoy sidecar is sent to before it is forwarded to the overlay address and the container_tls_proxy_port. Let's call this DIEGO_CELL_ENVOY_PORT
         },
         {
           ""container_port"": 2222,            <------ The port exposed on the app container for sshing onto the app container
           ""host_port"": 61013,                <------ The port on the Diego Cell where ssh traffic to your app container is sent to before it is forwarded to the overlay address and the ssh container_port
           ""container_tls_proxy_port"": 61002, <------ The ssh port inside of the app container that envoy is listening on for ssh traffic. This is the default value (currently unchangeable).
           ""host_tls_proxy_port"": 61015       <------ The port on the Diego Cell where ssh traffic to your app's envoy sidecar is sent to before it is forwarded to the overlay address and the ssh container_tls_proxy_port
         }
       ],
     ""instance_address"": ""10.255.116.6"",      <------ The overlay IP address of this app instance, let's call this the OVERLAY_IP
     ""state"": ""RUNNING"",
      ...
   }
   ```
0. Use the cfdot CLI to query BBS for desiredLRPs.

‚ùìWhat information is provided for desiredLRPs, but not for actualLRPs?
‚ùìWhat information is provided for actualLRPs, but not for desiredLRPs?
‚ùìHow does this match with the definition of desired and actual LRPs in the ""what"" section above?

### Expected Result
Get information from BBS about the desiredLRP and actualLRP for appA. Use cfdot CLI to discover the following values and record them.

## Recorded Values
Record the following values that you generated or discovered during this story.
```
APP_A_GUID=<value>
DIEGO_CELL_IP=<value>
CONTAINER_APP_PORT=<value>
DIEGO_CELL_APP_PORT=<value>
CONTAINER_ENVOY_PORT=<value>
DIEGO_CELL_ENVOY_PORT=<value>
OVERLAY_IP=<value>
```

## Resources
[cfdot docs](https://github.com/cloudfoundry/cfdot)
[diego design notes](https://github.com/cloudfoundry/diego-design-notes#what-are-all-these-repos-and-what-do-they-do)

üôè _If this story needs to be updated: please, please, PLEASE submit a PR. Amelia will be eternally grateful. How? Go to [this repo](https://github.com/pivotal/cf-networking-program-onboarding). Search for the phrase you want to edit. Make the fix!_","http-routes,questions"
Route Propagation - Part 3 - Route Emitter and NATS,feature,"## Assumptions
- You have a OSS CF deployed
- You have one [proxy](https://github.com/cloudfoundry/cf-networking-release/tree/develop/src/example-apps/proxy) app pushed and called appA
- You have one route mapped to appA called APP_A_ROUTE
- You have completed the previous stories in this track

## Recorded values from previous stories
```
APP_A_ROUTE=<value>
APP_A_GUID=<value>
DIEGO_CELL_IP=<value>
CONTAINER_APP_PORT=<value>
DIEGO_CELL_APP_PORT=<value>
CONTAINER_ENVOY_PORT=<value>
DIEGO_CELL_ENVOY_PORT=<value>
OVERLAY_IP=<value>
```

## What

There is one Route Emitter per Diego Cell and its job is to... emit routes. According to the ever helpful
[Diego Design Notes](https://github.com/cloudfoundry/diego-design-notes) the Route Emitter ""monitors DesiredLRP state
and ActualLRP state via the BBS. When a change is detected, the Route Emitter emits route registration and unregistration
messages to the GoRouter via the NATS message bus."" Even when no change is detected, the Route Emitter will periodically
emit the entire routing table as a kind of heartbeat.

For this story, let's look at the messages that the Route Emitter is publishing via NATS. Subscribing to these NATs messages
can be a helpful debugging technique.

## How

üìù **subscribe to NATs messages**
0. Bosh ssh onto the Diego Cell where your app is running and become root
0. Download ruby and the NATS gem
    ```
    apt-get install -y ruby ruby-dev
    gem install nats
    ```
0. Get NATS username, password, and server address
    ```
    cat /var/vcap/jobs/route_emitter/config/route_emitter.json | jq . | grep nats
    ```
0. Use the nats gem to connect to nats: `nats-sub ""*.*"" -s nats://NATS_USERNAME:NATS_PASSWORD@NATS_ADDRESS`. The `""*.*""` means that you are subscribing to all NATs messages.
    The Route Emitter registers routes every 20 seconds (by default) so that the GoRouter (which subscribes to these messages) has the most up-to-date information about which IPs map to which apps and routes. Depending on how many routes there are, this might be a lot of information.

0. Find the NATs message for APP_A_ROUTE.
 ```
 nats-sub ""*.*"" -s nats://NATS_USERNAME:NATS_PASSWORD@NATS_ADDRESS` | grep APP_A_ROUTE
 ```
 If you wait, you should see a message that contains information about the route you created. It will look something like this and contain APP_A_ROUTE:
 ```
   [#32] Received on [router.register] :
{
    ""host"": ""10.0.1.12"",
    ""port"": 61012,
    ""tls_port"": 61014,
    ""uris"": [
        ""proxy.meow.cloche.c2c.cf-app.com""     <--- This should match APP_A_ROUTE
      ],
    ""app"": ""6856799f-aebf-4e2b-81a5-28c74dfb6162"",
     ""private_instance_id"": ""a0d2b217-fa7d-4ac1-65a2-7b19"",
     ""private_instance_index"": ""0"",
    ""server_cert_domain_san"": ""a0d2b217-fa7d-4ac1-65a2-7b19"",
    ""tags"": {
         ""component"": ""route-emitter""
     }
}
 ```

‚ùìDo the values in the NATS message match the values you recorded previously from BBS? Which ones are present? Which ones aren't there?
‚ùìHow does it compare to the information in CAPI?

### Expected Result
Inspect NATs messages. Look at what route information is sent to the GoRouter.

## Resources
[NATS message bus repo](https://github.com/nats-io/gnatsd)
[NATS ruby gem repo](https://github.com/nats-io/ruby-nats)

üôè _If this story needs to be updated: please, please, PLEASE submit a PR. Amelia will be eternally grateful. How? Go to [this repo](https://github.com/pivotal/cf-networking-program-onboarding). Search for the phrase you want to edit. Make the fix!_","http-routes,questions"
Route Propagation - Part 4 - GoRouter,feature,"## Assumptions
- You have a OSS CF deployed
- You have one [proxy](https://github.com/cloudfoundry/cf-networking-release/tree/develop/src/example-apps/proxy) app pushed and called appA
- You have one route mapped to appA called APP_A_ROUTE
- You have completed the previous stories in this track

## Recorded values from previous stories
```
APP_A_ROUTE=<value>
APP_A_GUID=<value>
DIEGO_CELL_IP=<value>
CONTAINER_APP_PORT=<value>
DIEGO_CELL_APP_PORT=<value>
CONTAINER_ENVOY_PORT=<value>
DIEGO_CELL_ENVOY_PORT=<value>
OVERLAY_IP=<value>
```

## What
So the Route Emitter emits routes via the NATS message Bus. GoRouter subscribes to those messages and keeps a route table that is uses to route network traffic bound for CF apps and CF components.

Let's take a look at that route table.
## How

üìù **look at route table**
0. Bosh ssh onto the router vm and become root.
0. Install jq (a json manipulation and display tool)
 ```
 apt-get install jq
 ```
0. Get the username and password for the routing api
 ```
 head /var/vcap/jobs/gorouter/config/gorouter.yml
 ```
0. Get the routes table
 ```
 curl ""http://USERNAME:PASSWORD@localhost:8080/routes"" | jq .
 ```
0. Scroll through and look at the routes.
  ‚ùìHow does this differ from the route information you saw in CAPI?
   For example, you should see routes for CF components, like UAA and doppler.
   This because the GoRouter is in charge of routing traffic to CF apps *AND* to CF components.
0. Find APP_A_ROUTE in the list of routes. Let's dissect the most important bits.
    ```
    ""proxy.meow.cloche.c2c.cf-app.com"": [   <------ The name of the route! This should match APP_A_ROUTE
        {
          ""address"": ""10.0.1.12:61014"",     <------ This is where GoRouter will send traffic for this route. This should match DIEGO_CELL_IP:DIEGO_CELL_ENVOY_PORT
          ""tls"": true                       <------ This means Route Integrity is turned on, so the GoRouter will use send traffic to this app over TLS
        }
      ]
    ```
    See how the traffic is being sent to `10.0.1.12:61014` or DIEGO_CELL_IP:DIEGO_CELL_ENVOY_PORT?
    This means all traffic is being sent to the sidecar envoy via TLS, this is because route integrity is enabled.
    ‚ùìWhat port do you think would be listed here if route integrity was not enabled?

### Expected Result
Access the route table on the router vm. Inspect app routes and CF component routes.

See that the GoRouter sends traffic for this route to DIEGO_CELL_IP:DIEGO_CELL_ENVOY_PORT.
In the next story we will see what what is listening on that port on the cell.

## Resources

[GoRouter routing table docs](https://github.com/cloudfoundry/gorouter#the-routing-table)

üôè _If this story needs to be updated: please, please, PLEASE submit a PR. Amelia will be eternally grateful. How? Go to [this repo](https://github.com/pivotal/cf-networking-program-onboarding). Search for the phrase you want to edit. Make the fix!_","http-routes,questions"
Route Propagation - Part 4.5 - see what's listening with netstat,feature,"## Assumptions
- You have a OSS CF deployed
- You have one [proxy](https://github.com/cloudfoundry/cf-networking-release/tree/develop/src/example-apps/proxy) app pushed and called appA
- You have one route mapped to appA called APP_A_ROUTE
- You have completed the previous stories in this track

## Recorded values from previous stories
```
APP_A_ROUTE=<value>
APP_A_GUID=<value>
DIEGO_CELL_IP=<value>
CONTAINER_APP_PORT=<value>
DIEGO_CELL_APP_PORT=<value>
CONTAINER_ENVOY_PORT=<value>
DIEGO_CELL_ENVOY_PORT=<value>
OVERLAY_IP=<value>
```

## What
Netstat is a tool that can show information about network connections, routing tables, and network interface statistics.
In the previous story we saw that the GoRouter sent traffic for APP_A_ROUTE to DIEGO_CELL_IP:DIEGO_CELL_ENVOY_PORT.
Let's use netstat to see what is listening at on the Diego Cell and specifically at DIEGO_CELL_IP:DIEGO_CELL_ENVOY_PORT.

## How
üìù **look at open ports on a Diego Cell**
1. Ssh onto the Diego Cell where appA is deployed and become root.
1. Use netstat to look at open ports
 ```
 netstat -tulp
 # -t  <---- show tcp sockets
 # -u  <---- show udp sockets
 # -l  <---- display listening sockets
 # -p  <---- display PID/program name for sockets
 ```
  You should recognize the program names in the far right column. Most of them are the long running cf component processes.

1. Find the local address for the Route Emitter. What port is it running on? Does that match what is in the [spec file](https://github.com/cloudfoundry/diego-release/blob/develop/jobs/route_emitter/spec)?

1. Search for DIEGO_CELL_ENVOY_PORT in the output. Can you find it?

### Expected Result
You won't see the DIEGO_CELL_ENVOY_PORT anywhere in the netstat output because nothing is *actually* running there.
But if there's nothing running there, how does the traffic reach the app? Would you believe that iptables are involved?
Check out the next story to learn more :)

üôè _If this story needs to be updated: please, please, PLEASE submit a PR. Amelia will be eternally grateful. How? Go to [this repo](https://github.com/pivotal/cf-networking-program-onboarding). Search for the phrase you want to edit. Make the fix!_",http-routes
Route Propagation - Part 5 - DNAT Rules,feature,"## Assumptions
- You have a OSS CF deployed
- You have one [proxy](https://github.com/cloudfoundry/cf-networking-release/tree/develop/src/example-apps/proxy) app pushed and called appA
- You have one route mapped to appA called APP_A_ROUTE
- You have completed the previous stories in this track
- It will help if you have completed the ""iptables-primer"" track, but it is not required.

## Recorded values from previous stories
```
APP_A_ROUTE=<value>
APP_A_GUID=<value>
DIEGO_CELL_IP=<value>
CONTAINER_APP_PORT=<value>
DIEGO_CELL_APP_PORT=<value>
CONTAINER_ENVOY_PORT=<value>
DIEGO_CELL_ENVOY_PORT=<value>
OVERLAY_IP=<value>
```

## What
In a previous story you saw that the GoRouter sent traffic for APP_A_ROUTE to DIEGO_CELL_IP:DIEGO_CELL_ENVOY_PORT.
But in the previous story, you saw nothing was actually listening at that port on the Diego Cell. So how does the network traffic hit the app?
With the help of iptables rules of course! Everything always comes back to iptables rules.

Nothing is actually listening on the Diego Cell at port DIEGO_CELL_ENVOY_PORT. Instead, all packets that are sent there hit iptables rules that then redirect them to... somewhere. Let's find out!

Let's not brute force looking through every iptables rule. Instead, let's reason about what chain and table most likely contain these iptables rules.
Hint, these rules translate ingress network traffic sent from GoRouter.

## How

ü§î **Find those iptables rules**
Aidan Obley made a great diagram showing the different types of traffic in CF and which iptables chains they hit in what order.
We are currently concerned with ingress traffic, which is represented by the orange line.

0. Look at the diagram. Which chain does the ingress traffic hit first?
    ![traffic-flow-through-iptables-on-cf-diagram](https://storage.googleapis.com/cf-networking-onboarding-images/traffic-flow-through-iptables-on-cf.png)

0. Based on the previous diagram, the ingress traffic hits the prerouting chain first. Look at the diagram below and do some research to learn more about the raw, conn_tracking, mangle, and nat tables.
    Which table should contain the rules to redirect our traffic to a new address?
    ![iptables tables and chains diagram](https://storage.googleapis.com/cf-networking-onboarding-images/iptables-tables-and-chains-diagram.png)

    NAT stands for Network Address Translation. That sounds like what we want.  So let's look at iptables rules for the nat table on the prerouting chain.

0. Ssh onto the Diego Cell where your app is running and become root.
0. Run `iptables -S -t nat`
    You should see some custom chains attached to the PREROUTING chain. There will be one custom chain per app running on this Diego Cell.  They will look something like this.
    ```
    -A PREROUTING -j netin--a0d2b217-fa7d-4ac1-65
    -A PREROUTING -j netin--317736ed-70ac-4087-74
    ...
    ```
0. You should also see 4 rules that contain the OVERLAY_IP for appA. If you look closely you'll see that the ports in the iptables rules match the ports we saw when inspecting the actual LRPs.
    Which port represents what?
    ```
    -A netin--a0d2b217-fa7d-4ac1-65 -d 10.0.1.12/32 -p tcp -m tcp --dport 61012 -j DNAT --to-destination 10.255.116.6:8080
    -A netin--a0d2b217-fa7d-4ac1-65 -d 10.0.1.12/32 -p tcp -m tcp --dport 61013 -j DNAT --to-destination 10.255.116.6:2222
    -A netin--a0d2b217-fa7d-4ac1-65 -d 10.0.1.12/32 -p tcp -m tcp --dport 61014 -j DNAT --to-destination 10.255.116.6:61001
    -A netin--a0d2b217-fa7d-4ac1-65 -d 10.0.1.12/32 -p tcp -m tcp --dport 61015 -j DNAT --to-destination 10.255.116.6:61002
    ```

0. For appA, find the rule that will match with the traffic the GoRouter sends to DIEGO_CELL_IP:DIEGO_CELL_ENVOY_PORT. It should look something like this...
    ![example DNAT rule with explanation](https://storage.googleapis.com/cf-networking-onboarding-images/example-DNAT-rule-with-explanation.png)

    In summary, when the GoRouter sends network traffic to 10.0.1.12:61014 (DIEGO_CELL_IP:DIEGO_CELL_ENVOY_PORT) it gets redirected to 10.255.116.6:61001 (OVERLAY_IP:CONTAINER_ENVOY_PORT).
    But, looking at the information we learned about the actual LRP, the app isn't even listening on 10.255.116.6:61001, envoy is.
    When will the traffic finally reach the app!?!?

### Expected Result
Inspect the iptables rules that DNAT the traffic from the GoRouter and send it to the correct sidecar envoy.

## Resources
[iptables man page](http://ipset.netfilter.org/iptables.man.html)
[Aidan's iptables in CF ppt](https://docs.google.com/presentation/d/1qLkNu633yLHP5_S_OqOIIBETJpW3erk2QuGSVo71_oY/edit#slide=id.p)

üôè _If this story needs to be updated: please, please, PLEASE submit a PR. Amelia will be eternally grateful. How? Go to [this repo](https://github.com/pivotal/cf-networking-program-onboarding). Search for the phrase you want to edit. Make the fix!_",http-routes
Route Propagation - Part 6.1 - Envoy Primer,feature,"## Assumptions
- None

## What

Before you go further it will help if you read a quick primer on Envoy.

## How

1. üìö Read Julia Evan's blog post [""Some Envoy Basics""](https://jvns.ca/blog/2018/10/27/envoy-basics/).
 Unfortunately, the envoy in the docker container referenced in the blog post doesn't work anymore. However, just reading the post is enough to get a nice overview.

üôè _If this story needs to be updated: please, please, PLEASE submit a PR. Amelia will be eternally grateful. How? Go to [this repo](https://github.com/pivotal/cf-networking-program-onboarding). Search for the phrase you want to edit. Make the fix!_",http-routes
Route Propagation - Part 6.2 - Route Integrity and Envoy,feature,"## Assumptions
- You have a OSS CF deployed
- You have one [proxy](https://github.com/cloudfoundry/cf-networking-release/tree/develop/src/example-apps/proxy) app pushed and called appA
- You have one route mapped to appA called APP_A_ROUTE
- You have completed the previous stories in this track

## Recorded values from previous stories
```
APP_A_ROUTE=<value>
APP_A_GUID=<value>
DIEGO_CELL_IP=<value>
CONTAINER_APP_PORT=<value>
DIEGO_CELL_APP_PORT=<value>
CONTAINER_ENVOY_PORT=<value>
DIEGO_CELL_ENVOY_PORT=<value>
OVERLAY_IP=<value>
```

## What
A **proxy** is a process that sits in-between the client and the server and intercepts traffic before forwarding it on to the server. Proxies can add extra functionality, like caching or SSL termination.

In this case, Envoy is a sidecar proxy (Envoy can be other types of proxies too, but forget about that for now). The sidecar Envoy is only present when Route Integrity is turned on (which is done by default).

Route Integrity is when the GoRouter sends all app traffic via TLS. As part of the TLS handshake, the GoRouter validates the certificate's SAN against the ID found in its route table to make sure it is connecting to the intended app instance. This makes communication more secure and prevents stale routes in the route table from causing misrouting, which is a large security concern. Read more about how Route Integrity prevents misrouting [here](https://docs.cloudfoundry.org/concepts/http-routing.html#-preventing-misrouting).

The Envoy sidecar is the process that actually terminates the TLS traffic from the GoRouter making Route Integrity possible. Then the Envoy proxies it onto...can it be? finally?! YES! THE APP!!

Let's look at how the Envoy sidecar is configured to proxy traffic to the app.
## How

üìù **Look at envoy config**
0. Ssh onto AppA
0. Hit the Envoy admin endpoint `curl localhost:61003/admin`
    These are all of the endpoints you can hit. Try `/clusters` what do you see?
0. Run `curl localhost:61003/config_dump`. This gives you all of the information about how the Envoy is configured.
0. Search for the CONTAINER_ENVOY_PORT, in the example it is 61001. This is where the DNAT rules forwarded the traffic to, as we saw in the last story. Find a listener called `listener-8080` that looks similar to the following: 
    ```
     ""listeners"": [
      {
       ""name"": ""listener-8080"",                                                    <---- The name of the listener
       ""address"": {
        ""socket_address"": { ""address"": ""0.0.0.0"", ""port_value"": 61001}             <---- This listener is listening on port 61001. That's the CONTAINER_ENVOY_PORT we know and love!
       },
       ""filter_chains"": [
        {
         ""tls_context"": { ""require_client_certificate"": true },                    <---- This means Route Integrity is turned on
         ""filters"": [
          {
           ""name"": ""envoy.tcp_proxy"",
           ""config"": { ""stat_prefix"": ""0-stats"", ""cluster"": ""0-service-cluster"" }  <---- This is the name of the cluster where Envoy will forward traffic that is sent to the CONTAINER_ENVOY_PORT, let's call this CLUSTER-NAME
          }
         ]
        }
       ]
      }
     ]
    ```
0. In the same config_dump output, find the cluster, CLUSTER-NAME, that is referenced above. It should look something like this:
    ```
     ""clusters"": [
      {
       ""name"": ""0-service-cluster"",                                          <---- This is the name of the cluster, CLUSTER-NAME
       ""hosts"": [
        {
         ""socket_address"": { ""address"": ""10.255.116.6"", ""port_value"": 8080}  <---- This is the port that the app is listening on inside of the container, should match OVERLAY_IP and CONTAINER_APP_PORT
        }
       ]
      }
    ]
    ```

So the traffic gets sent to the OVERLAY_IP:CONTAINER_ENVOY_PORT, then the envoy forwards it on to OVERLAY_IP:CONTAINER_APP_PORT!

We made it! We finally made it to the end! Everything is set up and someone can use that route you made!

### Expected Result
Look at the Envoy's 8080 listener and related cluster and see how network traffic is sent to the app.

## Resources
[Route Integrity/Misrouting Docs](https://docs.cloudfoundry.org/concepts/http-routing.html#-preventing-misrouting)
[What is Envoy?](https://www.envoyproxy.io/docs/envoy/latest/intro/what_is_envoy)

üôè _If this story needs to be updated: please, please, PLEASE submit a PR. Amelia will be eternally grateful. How? Go to [this repo](https://github.com/pivotal/cf-networking-program-onboarding). Search for the phrase you want to edit. Make the fix!_",http-routes
Route Propagation - Part 7 - Wrap Up,feature,"## Assumptions
- You have completed the previous stories in this track

## What
Let's review!

## How
1. Go to a whiteboard and have one pair diagram what happens when an app dev creates and maps a new route.
1. Go to a whiteboard and have the other pair diagram what happens when a person on the internet makes an HTTP request to a CF route.

### Expected Result
You know everything about routes. (Just kidding.)

üôè _If this story needs to be updated: please, please, PLEASE submit a PR. Amelia will be eternally grateful. How? Go to [this repo](https://github.com/pivotal/cf-networking-program-onboarding). Search for the phrase you want to edit. Make the fix!_",http-routes
HTTP Routes ‚áß,release,,http-routes
Stale Routes Reenactment,feature,"## Assumptions
- You have a CF deployed

## What
Recap from http-route track: the GoRouter redirects traffic for a particular CF HTTP route to a Diego Cell IP and port. However, when one app is deleted, another app may later use the same Diego Cell IP and port.

In the happy path case, the following steps should happen in the following order:

- appA is pushed and is at 10.0.1.2:12345
- the Route Emitter sends a register route message to the GoRouter
- the GoRouter forwards traffic for appA to 10.0.1.2:12345
- appA is deleted
- the Route Emitter sends an unregister route message to the GoRouter
- üëç **the GoRouter does NOT forward traffic for appA to 10.0.1.2:12345**
- appB is pushed and is now at 10.0.1.2:12345
- the Route Emitter sends a register route message to the GoRouter
- the GoRouter forwards traffic for appB to 10.0.1.2:12345

That's a lot of components working together to make sure routes are sent to the correct place. Now imagine this situation where the Route Emitter is not sending out messages fast enough.

- appA is pushed and is at 10.0.1.2:12345
- the Route Emitter sends a register route message to the GoRouter
- the GoRouter forwards traffic for appA to 10.0.1.2:12345
- appA is deleted
- ~~the Route Emitter sends an unregister route message to the GoRouter~~
- ~~the GoRouter does NOT forward traffic for appA to 10.0.1.2:12345~~
- appB is pushed and is now at 10.0.1.2:12345
- ~~the Route Emitter sends a register route message to the GoRouter~~
- **the GoRouter continues to forward traffic for appA to 10.0.1.2:12345, where appA used to be, where appB currently is**
- üò± the user tried to access appA, but they were routed to appB instead

Yikes! This is an example of misrouting due to ""stale"" routes.

Let's set up a situation with stale routes manually and see how dangerous it is. Then in the next story we will look at how Route Integrity fixes this issue.

The Networking Program has had to fix several bugs related to stale routes. To replicate the bugs and test our fixes, we came up with the following method to simulate stale routes.
It took a surprisingly long time to come up with this idea. Enjoy our hard work. :)

## How

ü§î **cause stale routes**
1. Route Integrity is turned on by default with CF Deployment. Let's turn it off and see what happened before Route Integrity. But first, let's save the current manifest for the next story.
 ```
bosh manifest > /tmp/env-with-route-integrity.yml
 ```

1. Redeploy your CF with Route Integrity turned off, using [this opsfile](https://github.com/cloudfoundry/cf-deployment/pull/745).

1. Push one instance of [proxy](https://github.com/cloudfoundry/cf-networking-release/tree/develop/src/example-apps/proxy) and call it appA.

1. Ensure that appA has an HTTP route.

1. Push one instance of [dora](https://github.com/cloudfoundry/cf-acceptance-tests/tree/master/assets/dora) and name it appB.

1. Ensure that there is an HTTP Route mapped to appB.

1. Make sure an instance of appA and appB are on the same Diego Cell. This can be achieved through scaling appB if it doesn't happen at first.

1. Curl appA. See that you get the expected result for appA.

1. In previous http-route stories, you learned that the route table on the GoRouter maps routes to particular Diego Cell IPs and ports. Then the GoRouter sends traffic to the Diego Cell IP and port. Then the traffic is rerouted to an app's overlayIP and app port using iptables rules on the nat table. Change the iptables rules so that the Diego Cell port that maps to appA now, incorrectly, redirects traffic to appB. This will imitate route staleness. Go back to the http-route DNAT stories if you need help doing this.

1. Curl the route for appA.

### Expected Result
Even though you curled the route for appA, because the routes for appA were ""stale"" you got back the information for appB.

## Questions

‚ùì Why is this dangerous?
‚ùì What is the implications for this on a shared production environment, like PWS?
‚ùì What could cause routes to become stale? What could exacerbate this problem?
‚ùì Before Route Integrity, what could app devs do to prevent stale routes from accidentally releasing their data?

üôè _If this story needs to be updated: please, please, PLEASE submit a PR. Amelia will be eternally grateful. How? Go to [this repo](https://github.com/pivotal/cf-networking-program-onboarding). Search for the phrase you want to edit. Make the fix!_","route-integrity,deploy,questions"
Route Integrity Demonstration,feature,"## Assumptions
- You have a CF deployed

## What

You saw the dangers of stale routes in the last story. This story will explore how Route Integrity solves this issue. Route Integrity is enabled by enforcing TLS (or mTLS) between the GoRouter and the apps it routes to.
By default only TLS (not mTLS) is enforced. This is because mTLS will break the cf ssh command.

(Side Note: Confusingly, this feature is called ""Route Integrity"" by engineers, but is called ""(m)TLS to apps"" or ""encrypting traffic from the GoRouter to backends"" in documentation. I will continue calling it Route Integrity, because it is more succinct and sounds cooler.)

Let's set up the same experiment as the previous story and see that even when you imitate route staleness, that you are no longer able to see the data from the incorrect app.

## How
ü§î **Send traffic to a stale route**

1. Deploy your CF with Route Integrity enabled with TLS. Use the manifest you saved in the last story at `/tmp/env-with-route-integrity.yml`.

1. Push an app, appA with an HTTP route.

1. Push a different app, appB, that will respond differently than appA. Ensure there is an HTTP Route mapped to appB. Make sure an instance of appA and appB are on the same Diego Cell. You can achieve this by scaling appB, but make sure there is only 1 instance of appA.

1. Curl appA. See that you get the expected result.

1. Change the iptables rules so that the Diego Cell port that maps to appA now, incorrectly, redirects traffic to appB. This will imitate route staleness.

1. In another terminal, tail the gorouter.stdout.log.

1. Curl the route for appA.

### Expected Result
When you curl appA, you should get a 503 status code.
```
$ curl appA.cf-app.com
503 Service Unavailable
```

In the GoRouter bosh logs you should see a line about pruning the bad route.

```
{""log_level"":3,""timestamp"":1554761639.745829,""message"":""prune-failed-endpoint"",""source"":""vcap.gorouter.registry"",""data"":{""route-endpoint"":{""ApplicationId"":""bf1cdd21-ed5b-429b-93ef-f74a4aadc55f"",""Addr"":""10.0.1.13:61010"",""Tags"":{""component"":""route-emitter""},""RouteServiceUrl"":""""}}}

{""log_level"":3,""timestamp"":1554761639.7473993,""message"":""backend-endpoint-failed"",""source"":""vcap.gorouter"",""data"":{""route-endpoint"":{""ApplicationId"":""bf1cdd21-ed5b-429b-93ef-f74a4aadc55f"",""Addr"":""10.0.1.13:61010"",""Tags"":{""component"":""route-emitter""},""RouteServiceUrl"":""""},""error"":""x509: certificate is valid for 0c2ca10a-0c19-4288-68e8-8d1f, not e5fdb45c-1b41-4602-45ac-b49e"",""attempt"":1,""vcap_request_id"":""3673ccd9-44ee-4d81-4a45-0ea75a96121c""}}
```

Route Integrity doesn't actually prevent route staleness, but it *does* prevent leaking data from appB when you are trying to access appA.

## Look at the code
GoRouter analyses different types of errors from the backend. In the case of misrouting, we are running into this [HostnameMismatch error](https://github.com/cloudfoundry/gorouter/blob/master/proxy/fails/basic_classifiers.go#L44-L51).

Depending on the type of error, GoRouter may choose to retry or not. Look at these [failure classifiers](https://github.com/cloudfoundry/gorouter/blob/master/proxy/fails/classifier_group.go#L5-L17).

## Questions
1. ‚ùìAre HostnameMismatch errors retried?
1. ‚ùìIf you had multiple instances of appA what do think would've happened? (Extra Credit: Try it out. Were you correct?)
1. ‚ùìRoute Integrity was introduced to fix misrouting due to route staleness. What other benefits does Route Integrity provide?
1. ‚ùìKeep curling the HTTP route for appA several times over 1 minute. Sometimes you get a 503 and sometimes you get a 404. Why?

## Links
[CF Docs - TLS to Apps](https://docs.cloudfoundry.org/concepts/http-routing.html#tls-to-back-end)

üôè _If this story needs to be updated: please, please, PLEASE submit a PR. Amelia will be eternally grateful. How? Go to [this repo](https://github.com/pivotal/cf-networking-program-onboarding). Search for the phrase you want to edit. Make the fix!_","route-integrity,deploy,questions"
Checking the SAN for Route Integrity,feature,"## Assumptions
- You have a CF deployed with Route Integrity enabled
- You have one [proxy](https://github.com/cloudfoundry/cf-networking-release/tree/develop/src/example-apps/proxy) app pushed and called appA
- You have one route mapped to appA called APP_A_ROUTE

## What
In the last story you saw that Route Integrity ensures that appA.cf-app.com is *actually going to* appA and not misrouting to appB due to stale routes. But how does it  work?

Route Integrity is implemented by giving the GoRouter a [CA certificate](https://github.com/cloudfoundry/routing-release/blob/develop/jobs/gorouter/spec#L106-L107) at deploy time. At runtime, when an app container is created, Diego generates a certificate from that CA for each app instance and puts it in the app container. The certificate has a unique subject alternative name (SAN) per app instance.

Diego runs a sidecar Envoy inside of the app container which intercepts all incoming traffic from the GoRouter. It uses the generated certificate to terminate TLS before forwarding traffic to the app. When the GoRouter checks the certificate from the Envoy sidecar, it checks that the SAN matches the app instance id that it has for that IP and port. This way GoRouter is able to make sure that appA.cf-app.com is *actually going to* appA and not misrouting to appB due to stale routes.

All of this work means that the app developer does not need to do anything in order for the GoRouter to app traffic to be sent over TLS. It should ""just work"".

Let's see how the GoRouter compares the application certificate SAN to make sure it is routing correctly.

## How
ü§î **Find the SAN in the Routes table**
1. Bosh ssh onto the Router VM.
1. Look at the routes table (see the story ""Route Propagation - Part 4 - GoRouter"" if you need a reminder on how to do this).
1. Find the entry for APP_A_ROUTE.
    It should look something like this
 ```
  ""proxy.apps.mitre.c2c.cf-app.com"": [
    {
      ""address"": ""10.0.1.18:61022"",
      ""tls"": true,
      ""ttl"": 120,
      ""tags"": {
        ""component"": ""route-emitter""
      },
      ""private_instance_id"": ""16b6f1fc-347c-4565-71e0-bf7f"",
      ""server_cert_domain_san"": ""16b6f1fc-347c-4565-71e0-bf7f""       <------- This is the SAN that GoRouter is matching against.
    },
 ```

üìù  **Look at the SAN in the certificate**

1. Get into the app container
 ```
cf ssh appA
 ```
1. get the location of the certificate
 ```
env | grep CF_INSTANCE_CERT
 ```
1. Look at the certificate
 ```
cat $CF_INSTANCE_CERT
 ```
1. Use openssl to read the certificate
 ```
openssl x509 -text -in  $CF_INSTANCE_CERT
 ```

You should see a section that looks like this
 ```
 X509v3 Subject Alternative Name:
          DNS:16b6f1fc-347c-4565-71e0-bf7f,   <-------  This matches the server_cert_domain_san
          IP Address:10.255.96.8              <-------  The overlay ip of the app instance
 ```

### Expected Result
You should see the same SAN value stored in GoRouter routes table and in the app's certificate.

‚ùìIf you had multiple instances of appA would they have the same SAN? (Extra Credit: Try it out. Were you correct?)

## Links
[CF Docs - TLS to Apps](https://docs.cloudfoundry.org/concepts/http-routing.html#tls-to-back-end)
[Using Instance Identity Credentials](https://docs.cloudfoundry.org/devguide/deploy-apps/instance-identity.html)

üôè _If this story needs to be updated: please, please, PLEASE submit a PR. Amelia will be eternally grateful. How? Go to [this repo](https://github.com/pivotal/cf-networking-program-onboarding). Search for the phrase you want to edit. Make the fix!_","route-integrity,questions"
Route Integrity ‚áß,release,,route-integrity
User Workflow: Container to Container Networking,feature,"## Assumptions
- You have a CF deployed with silk release
- You have one [proxy](https://github.com/cloudfoundry/cf-networking-release/tree/develop/src/example-apps/proxy) app pushed and called appA
- You have one route mapped to appA called APP_A_ROUTE

## What

In the HTTP route track of stories you learned about the dataflow for HTTP traffic. But what if appA (an app within CloudFoundry) wants to talk to appB (another app within CloudFoundry)? Before Container to Container networking (c2c) there was no shortcut for intra-CF traffic. Without c2c, if appA wanted to talk to appB, then the traffic had to travel outside of the CF foundation, hit the external load balancer, and go through the normal HTTP traffic flow.

```
Life Before C2C                                  +------+
                                                 |      |
                                                 |      |
          +------------------------------------+ | AppA |
          |                                      |      |
          |                                      |      |
          |                                      +------+
          |
          v                                      +------+
                            +-----------+        |      |
+------------------+        |HTTP Router|        |      |
|HTTP Load Balancer| +----> |(GoRouter) | +----> | AppB |
+------------------+        +-----------+        |      |
                                                 |      |
                                                 +------+

```

So many extra hops for apps within the same CF! Especially if the apps are on the same Diego Cell!

Those hops come with extra latency. It can also come with an extra security risk. If appB  *only* needs to be accessed by appA (for example if appA is the frontend microservice and appB is the backend microservice for appA), appB would still need to be accessible via an HTTP route! This is exposing appB to more attack vectors than it should be.

With container to container networking (c2c) apps within a foundation can talk directly to each other. Now appA can talk to appB without leaving the CF foundation. And appB doesn't need to be accessible via an HTTP route (just an internal one, we'll get to that later in the service discovery track).

```
Life with C2C

+------+        +------+
|      |        |      |
|      |        |      |
| AppA | +----> | AppB |
|      |        |      |
|      |        |      |
+------+        +------+
```

In order for appA to be *able* to talk to appB, it needs to have permission. You will need to create a network policy.

Let's ignore the technical implementation for now and go through the user workflow.

## How

üìù**Use Container to Container Networking**

1. Push another [proxy](https://github.com/cloudfoundry/cf-networking-release/tree/develop/src/example-apps/proxy) app named appB. Use the `--no-route` so that no HTTP route is created for appB.
 ```
 cf push appB --no-route
 ```
1. Get the overlay IP for appB `cf ssh appB -c ""env | grep CF_INSTANCE_INTERNAL_IP""`
   (An explanation of what ""overlay"" means awaits in future stories! For now just know that each app instance has a unique overlay IP that c2c uses.)

1. Get onto the container for appA and curl the appB internal IP and app port.
   ```
cf ssh appA
watch  ""curl CF_INSTANCE_INTERNAL_IP:8080""
   ```
   You should get a `Connection refused` error because there is no network policy yet.

1.  In another terminal, add a network policy from appA to appB, with protocol tcp, on port 8080.
 ```
 cf add-network-policy appA appB --protocol tcp --port 8080
 ```

### Expected Result
After you add the policy, the curl from inside of the appA container to appB should succeed.
If it doesn't work, check that you created the policy in the correct direction, from appA --> appB, not the other way around.

üôè _If this story needs to be updated: please, please, PLEASE submit a PR. Amelia will be eternally grateful. How? Go to [this repo](https://github.com/pivotal/cf-networking-program-onboarding). Search for the phrase you want to edit. Make the fix!_","c2c,user-workflow"
A Container Networking Overview by Julia Evans,feature,"## What 

Before we get into the specifics about container networking in Cloud Foundry, let's learn about container networking _in general_.

And there's no better way to spend your time than reading a blog post by Julia Evans üíï.

## How

1. üìöRead [Julia Evans' blog post ""A container networking overview""](https://jvns.ca/blog/2016/12/22/container-networking/)
1. üçêTell your pair two things you learned from this blog post.

## Bonus

1. Spin up a docker container and try the commands in the blog post for yourself!

üôè _If this story needs to be updated: please, please, PLEASE submit a PR. Amelia will be eternally grateful. How? Go to [this repo](https://github.com/pivotal/cf-networking-program-onboarding). Search for the phrase you want to edit. Make the fix!_",c2c
Overlay vs Underlay,feature,"## Assumptions
- None

## What

The **underlay network** is the network that you're given to work with, on top of which you build a virtual **overlay network**. Routing for overlay networks is done at the software layer (in CF we use iptables rules). Overlay networks are used to create layers of abstraction that can be used to run multiple separate layers on top of the physical network ‚Äî the bottom underlay network. These are general definitions that are not specific to Cloud Foundry.

** Your ** underlay network is often someone else\'s overlay network, that engineer just works on a lower abstraction layer and might work on an IaaS rather than a PaaS, for example. It\'s all relative! ü§Ø

Routing to an app using the Diego Cell IP and port is done on what we will refer to as the **underlay network**. Container to container networking (c2c) is done on what we will refer to as the **overlay network**.

## Resources
- [Difference between overlay and underlay](https://ipwithease.com/difference-between-underlay-network-and-overlay-network/)

üôè _If this story needs to be updated: please, please, PLEASE submit a PR. Amelia will be eternally grateful. How? Go to [this repo](https://github.com/pivotal/cf-networking-program-onboarding). Search for the phrase you want to edit. Make the fix!_",c2c
Iptables Primer,feature,"Please go to the section labeled ""iptables-primer"" and complete those stories before moving on.

üôè _If this story needs to be updated: please, please, PLEASE submit a PR. Amelia will be eternally grateful. How? Go to [this repo](https://github.com/pivotal/cf-networking-program-onboarding). Search for the phrase you want to edit. Make the fix!_",c2c
Container to Container Networking - Part 0 - Dataflow Overview,feature,"## Assumptions
- None :)

## What
In the last story you learned the difference between underlay networks (physical) and overlay networks (software).

Let's see how both the overlay and underlay networks are used when one app talks to another using container to container networking (c2c).

Each step marked with a ‚ú® will be explained in more detail in its own story.

## How
Follow the steps below on the diagram. (Higher quality diagram [here](https://storage.googleapis.com/cf-networking-onboarding-images/c2c-data-plane.png).)

![c2c traffic flow](https://storage.googleapis.com/cf-networking-onboarding-images/overlay-underlay-silk-network.png)

1. AppB (10.255.1.4) makes a request to AppA's overlay IP address (10.255.2.7). This packet is called the overlay packet (aka the c2c packet).
1. ‚ú® The packet exits the app container through the veth interface.
1. ‚ú® The overlay packet is marked with a ...mark... that is unique to the source app.
1. ‚ú® Because the packet is an overlay packet, it is sent to the silk-vtep interface on the Diego Cell. This interface is a VXLAN interface.
1. ‚ú® The overlay packet is encapsulated inside of an underlay packet. This underlay packet is addressed to underlay IP of the Diego Cell where the destination app is located (appA in this case).
1. The underlay packet exits the cell.
1. The packet then travels over the physical underlay network to the correct Diego Cell.
1. The packet arrives to the correct Diego Cell
1. The underlay packet is decapsulated. Now it's just the overlay packet again.
1. ‚ú® Iptables rules check that appA is allowed to talk to appB based on the mark on the overlay packet.
1. If traffic is allowed, the overlay network directs the traffic to the correct place.
Yay!

### Expected Result

You should have a basic overview of the data path for container to container networking...even if you don't understand it all yet.
The next few stories will go through and explain each of the steps marked with a ‚ú®.

## Resources
- [Difference between overlay and underlay](https://ipwithease.com/difference-between-underlay-network-and-overlay-network/)

üôè _If this story needs to be updated: please, please, PLEASE submit a PR. Amelia will be eternally grateful. How? Go to [this repo](https://github.com/pivotal/cf-networking-program-onboarding). Search for the phrase you want to edit. Make the fix!_",c2c
Container to Container Networking - Part 1.1 - Network Namespaces,feature,"## Assumptions
- You have an OS CF deployed
- You have done the other stories in this track

## Review
This track of stories is going to go through the steps (listed below) that were covered in the dataflow overview.
The steps and diagram will be at the top of each story in case you need to orient yourself. Higher quality diagram [here](https://storage.googleapis.com/cf-networking-onboarding-images/c2c-data-plane.png).

![c2c traffic flow](https://storage.googleapis.com/cf-networking-onboarding-images/overlay-underlay-silk-network.png)

1. AppB (on Diego Cell 1) makes a request to AppA's overlay IP address (on Diego Cell 2). This packet is called the overlay packet (aka the c2c packet).
1. **The packet exits the app container through the veth interface. <------- CURRENT STORY**
1. The overlay packet is marked with a ...mark... that is unique to the source app.
1. Because the packet is an overlay packet, it is sent to the silk-vtep interface on the Diego Cell. This interface is a VXLAN interface.
1. The overlay packet is encapsulated inside of an underlay packet. This underlay packet is addressed to underlay IP of the Diego Cell where the destination app is located (appA in this case).
1. The underlay packet exits the cell.
1. The packet then travels over the physical underlay network to the correct Diego Cell.
1. The packet arrives to the correct Diego Cell
1. The underlay packet is decapsulated. Now it's just the overlay packet again.
1. Iptables rules check that appA is allowed to talk to appB based on the mark on the overlay packet.
1. If traffic is allowed, the overlay network directs the traffic to the correct place.

## What
Each CF app runs in a container, but what *is* a container? A container is a collection of **namespaces** and **cgroups**.

**Namespaces** ""partition kernel resources such that one set of processes sees one set of resources while another set of processes sees a different set of resources"" (thanks [wiki](https://en.wikipedia.org/wiki/Linux_namespaces)). There are different types of namespaces. For example, the mount namespace lets processes see different file trees. Another example (most related to this onboarding) is the network namespace. The network namespace isolates network interfaces (we'll get into what those are in the next story).

**Cgroups** (pronounced cee-groups) are resource limits. Cgroups let you say: ""these processes can only use 1G of memory"".

Most important in this onboarding context is the networking namespace. Container networking components are responsible for setting up the networking namespace for each app.

Even the bosh processes are run in containers! In CF this is done with [Bosh Process Manager (BPM)](https://github.com/cloudfoundry/bpm-release).

In this story you'll play around with BPM containers, network namespaces, and even make a network namespace for yourself.

## How

1. Read Julia Evan's post: [What even is a container](https://jvns.ca/blog/2016/10/10/what-even-is-a-container/)

üìù **Look at a container**
1. Ssh onto a Diego Cell and become root.
1. Look at the network interfaces (again, we'll go deeper in the next story).
 ```
ifconfig
 ```
1. Inspect the directories that the root user has access to. For example, look at all the log files.
 ```
ls /var/vcap/sys/log
 ```
1. Get into the BPM container for the vxlan-policy-agent.
 ```
bpm list
bpm shell vxlan-policy-agent
 ```
1. Look at the network interfaces. How do they compare to the host vm network interfaces?
1. Look at the log files you can access. How do they compare to the files accessible to root user?

 ‚ùìBased on this information, does BPM create a [mount namespace](https://medium.com/@teddyking/linux-namespaces-850489d3ccf) for the vxlan-policy-agent container?
 ‚ùìBased on this information, does BPM create a network namespace for the vxlan-policy-agent container?
1. Exit the container.

üìù **Make your own network namespace**

1. Still on a Diego Cell as root, create your own network namespace called meow.
 ```
ip netns add meow
```
1. List all of the networking namespaces
 ```
ip netns
 ```
 You should only see meow. Hmmm. You might think you would see the other networking namespaces for all the apps on this cell. (I certainly thought so when I first tried this.) You'll learn how to view an app's networking namespace one day, I promise.

1. Curl google.com from the Diego Cell. See that it works! This is because Application Security Groups allow it. (Remember ASGs?! You might or might not have done the ASG stories yet. tl;dr ASGs are iptables firewall rules for egress traffic.)

1. Curl google.com from inside of your networking namespace
 ```
ip netns exec meow curl google.com
 ```

What? It doesn't work!? You should see `curl: (6) Could not resolve host: google.com`. Try another URL. They will all fail.

### Expected Outcome
The meow networking namespace can't send any traffic out of the container. By default, network namespaces are completely isolated and have no network interfaces.
In the next story you'll explore network interfaces. You'll learn why the meow namespace needs one in order for you to curl google.com.

## Resources
[iptables netns man page](http://man7.org/linux/man-pages/man8/ip-netns.8.html)
[linux network namespaces/veth/route table blog](https://devinpractice.com/2016/09/29/linux-network-namespace/)
[network namespaces blog](https://blogs.igalia.com/dpino/2016/04/10/network-namespaces/)
[interface explanations](https://www.computerhope.com/unix/uifconfi.htm)
[linux namespaces overview](https://medium.com/@teddyking/linux-namespaces-850489d3ccf)

üôè _If this story needs to be updated: please, please, PLEASE submit a PR. Amelia will be eternally grateful. How? Go to [this repo](https://github.com/pivotal/cf-networking-program-onboarding). Search for the phrase you want to edit. Make the fix!_","c2c,questions"
Container to Container Networking - Part 1.2 - Network Interfaces,feature," ## Assumptions
- You have an OS CF deployed
- You have done the other stories in this track
- You have the meow network namespace created
- You have one [proxy](https://github.com/cloudfoundry/cf-networking-release/tree/develop/src/example-apps/proxy) app pushed and named appA (the fewer apps you have deployed the better)

## Review

This track of stories is going to go through the steps (listed below) that were covered in the dataflow overview.
The steps and diagram will be at the top of each story in case you need to orient yourself. Higher quality diagram [here](https://storage.googleapis.com/cf-networking-onboarding-images/c2c-data-plane.png).

![c2c traffic flow](https://storage.googleapis.com/cf-networking-onboarding-images/overlay-underlay-silk-network.png)

1. AppB (on Diego Cell 1) makes a request to AppA's overlay IP address (on Diego Cell 2). This packet is called the overlay packet (aka the c2c packet).
1. **The packet exits the app container through the veth interface. <------- CURRENT STORY**
1. The overlay packet is marked with a ...mark... that is unique to the source app.
1. Because the packet is an overlay packet, it is sent to the silk-vtep interface on the Diego Cell. This interface is a VXLAN interface.
1. The overlay packet is encapsulated inside of an underlay packet. This underlay packet is addressed to underlay IP of the Diego Cell where the destination app is located (appA in this case).
1. The underlay packet exits the cell.
1. The packet then travels over the physical underlay network to the correct Diego Cell.
1. The packet arrives to the correct Diego Cell
1. The underlay packet is decapsulated. Now it's just the overlay packet again.
1. Iptables rules check that appA is allowed to talk to appB based on the mark on the overlay packet.
1. If traffic is allowed, the overlay network directs the traffic to the correct place.

## What
In this story you are going to look at network interfaces.

A network interface is ... the interface between two different networks, physical or virtual.  You can list network interfaces with `ifconfig` (old way) or `ip link list` (new way).
In order to have packets from a CF app leave an app container, there needs to be a network interface that can send packets elsewhere. In the CF case, we want them to go to the Diego Cell.
In order to have packets leave the Diego Cell, there needs to be a network interface to the underlay network.

Let's look at the interfaces on the Diego cell and in our meow network namespace.

## How
üìù **Look at network interfaces**

1. List all of the network interfaces in the Diego Cell (this output is edited for brevity and clarity)
  ```
$ ip link
1: lo                 <------------- The loopback network interface that lets the system communicate with itself over localhost.
2: eth0               <------------- A ethernet interface. Traffic goes here to leave the Diego Cell.
1555: silk-vtep       <------------- A VXLAN overlay network interface. Overlay packets go here to be encapsulated in an  underlay packet before exiting the Diego Cell.
1559: s-010255096003@if1558: link-netnsid 0   <-------------  The interface that links to the network namespace with id 0. The name is `s-CONTAINER-ID`. This is the veth interface.
                                                                 There will be one of these network interfaces per app on the Diego Cell.
  ```

1. Now list all of the networking interfaces in the meow networking namespace
  ```
ip netns exec meow ip link
  ```
Nothing! No wonder you can't curl google.com! There is no network interface for packets to travel through.

The solution is to create a veth (virtual ethernet) pair. A veth pair consists of two virtual ethernet interfaces. One is placed in the host network namespace, the other in the meow network namespace. The veth pair acts like a bridge between the network namespace and the host.
You already saw one side of the veth pair for the proxy app when you ran `ip link` inside of the Diego Cell.  Let's look at the other half of the veth pair.

Side note: Why can't each networking namespace connect directly to `eth0`? ""One of the consequences of network namespaces is that only one interface could be assigned to a namespace at a time. If the root namespace owns eth0, which provides access to the external world, only programs within the root namespace could reach the Internet.""This explanation comes the extra extra credit link about [making your own veth pair](https://blogs.igalia.com/dpino/2016/04/10/network-namespaces/).

ü§î **Look at network interfaces inside the proxy app container**
1. Ssh proxy app.
1. List all of the network interfaces.

### Expected Result
You should see an eth0 interface inside of the proxy app container. This is how traffic exits the app container.

## Extra Credit
Look at the [code](https://github.com/cloudfoundry/silk/blob/master/cni/lib/pair_creator.go) and [tests](https://github.com/cloudfoundry/silk/blob/master/cni/lib/pair_creator_test.go) in silk where veth pairs are set up.

## Extra Extra Credit
üìù **Make your own veth pair **
1. Follow [these instructions](https://blogs.igalia.com/dpino/2016/04/10/network-namespaces/) to create a veth pair to connect the meow network namespace. If successful, you will be able to curl google.com

## Resources
[interface explanations](https://www.computerhope.com/unix/uifconfi.htm)
[linux network namespaces/veth/route table blog](https://devinpractice.com/2016/09/29/linux-network-namespace/)

üôè _If this story needs to be updated: please, please, PLEASE submit a PR. Amelia will be eternally grateful. How? Go to [this repo](https://github.com/pivotal/cf-networking-program-onboarding). Search for the phrase you want to edit. Make the fix!_",c2c
Container to Container Networking - Part 2 - Marks,feature," ## Assumptions
- You have an OS CF deployed
- You have done the other stories in this track
- You have two [proxy](https://github.com/cloudfoundry/cf-networking-release/tree/develop/src/example-apps/proxy) apps pushed and named appA and appB (the fewer apps you have deployed the better)

## Review
This track of stories is going to go through the steps (listed below) that were covered in the dataflow overview.
The steps and diagram will be at the top of each story in case you need to orient yourself. Higher quality diagram [here](https://storage.googleapis.com/cf-networking-onboarding-images/c2c-data-plane.png).

![c2c traffic flow](https://storage.googleapis.com/cf-networking-onboarding-images/overlay-underlay-silk-network.png)

1. AppB (on Diego Cell 1) makes a request to AppA's overlay IP address (on Diego Cell 2). This packet is called the overlay packet (aka the c2c packet).
1. The packet exits the app container through the veth interface.
1. **The overlay packet is marked with a ...mark... that is unique to the source app.  <------- CURRENT STORY**
1. Because the packet is an overlay packet, it is sent to the silk-vtep interface on the Diego Cell. This interface is a VXLAN interface.
1. The overlay packet is encapsulated inside of an underlay packet. This underlay packet is addressed to underlay IP of the Diego Cell where the destination app is located (appA in this case).
1. The underlay packet exits the cell.
1. The packet then travels over the physical underlay network to the correct Diego Cell.
1. The packet arrives to the correct Diego Cell
1. The underlay packet is decapsulated. Now it's just the overlay packet again.
1. Iptables rules check that appA is allowed to talk to appB based on the mark on the overlay packet.
1. If traffic is allowed, the overlay network directs the traffic to the correct place.

## What
In the last story we found out that packets leave the app container over the veth pair interface. In this story we are going to look at how overlay packets are marked.

First off, *why* are packets marked?
Packets are marked with a mark that is unique to the source app. Each instance of the source app has its packets marked with the same ID. If there is a c2c policy, then on the destination Diego Cell there are iptables rules that allow traffic with a certain mark to certain destinations. The policies look like the following diagram. Using one mark per source app, decreases the number of iptables rules needed per c2c policy, especially when there are large number of app instances.

![markful networking policy diagram](https://storage.googleapis.com/cf-networking-onboarding-images/diagram-of-silk-networking-policies.png)

If packets weren't marked we *could* use the overlay IP as a unique identifier. However, this would create the need for many more iptables rules, especially when there are a large number of app instances.

![markless networking policy diagram](https://storage.googleapis.com/cf-networking-onboarding-images/diagram-of-flannel-networking-policies.png)

You will learn more about how the c2c policies check the mark in later stories (hint: it uses iptables). For now, let's focus on how traffic is marked (hint: it uses iptables).

Here is an example iptables rule that sets a mark.
![setmark iptables rule example](https://storage.googleapis.com/cf-networking-onboarding-images/set-mark-iptables-rule-example.png)

In this story we are going to find the applicable set-xmark rules for our app and we're going to find out where that mark value comes from.

## How
üìù **Find set-xmark rules**
1. Delete all network policies. This time you are going to use the networking API because former policies from deleted apps can linger in the database, but not show up in the CLI.
 ```
 cf curl /networking/v1/external/policies > /tmp/policies.json
 cf curl -X POST /networking/v1/external/policies/delete -d @/tmp/policies.json

 # check that they are all deleted
 cf curl /networking/v1/external/policies
 ```

1. Ssh onto the Diego Cell where appA is located and become root
1. Look for the iptables rules that set marks.
 ```
iptables -S | grep set-xmark
 ```
 Nothing! This is because there are no policies. A mark is only allocated to an app when that app is used in a container to container (c2c) networking policy.

1. In a different terminal, add a c2c policy from appA to appB  (`cf add-network-policy --help`)
1. Back on the Diego Cell, look again for iptables rules that set marks
 ```
iptables -S | grep set-xmark
 ```

You should see something that looks like the colorful example above. Copy and paste it here.
```
# PASTE THE SET-XMARK RULE HERE
```

The source IP is the overlay IP for your app. The comment is the app guid for appA. And the mark is...well... where *does* the mark come from?

When a c2c policy is created, the policy server determines if the app has a mark already or not. If the app doesn't have a mark yet, it creates one. Let's look at all these marks.
The marks are an internal implementation of how c2c policies work, so they are not exposed on the external API (the API the CLI uses). But there is also an internal policy server API. The internal policy server API is the API that other CF components, like the vxlan-policy-agent, use.

üìù **Look at marks via internal policy server API**

1. You will need certs to call this API, those certs are located on the Diego Cell at `/var/vcap/jobs/vxlan-policy-agent/config/certs`
1. Follow the [docs](https://github.com/cloudfoundry/cf-networking-release/blob/develop/docs/policy-server-internal-api.md) for how to list all of the c2c policies.
You should see something like the following. The tag for appA should match the mark you saw in the iptables rule.
 ```
{
  ""total_policies"": 1,
  ""policies"": [
    {
      ""source"": {
        ""id"": ""90ff1b89-a69d-4c77-b1bd-415ae09833ed"",  <------- AppA guid
        ""tag"": ""0004""                                  <------- AppA mark, should match what you saw in the iptables rule above
      },
      ""destination"": {
        ""id"": ""0babce4f-6739-4fc8-8f74-01f11179bfe5"",  <------- AppB guid
        ""tag"": ""0005"",                                 <------- AppB mark
        ""protocol"": ""tcp"",
        ""ports"": { ""start"": 8080, ""end"": 8080 }
      }
    }
  ]
}
 ```

‚ùìHey! AppB has a mark too. Why?
‚ùìMarks on packets are limited to 16 bits. How many unique marks is this? Does this give you scaling concerns for c2c networking?

### Expected Outcome
The data about the tag for the source app from the internal policy server API should match the mark in the iptables rule.

## Look at the Code
In the vxlan policy agent (vpa), there is a component called the planner. The planner gets information from the internal policy server API about all of the c2c policies. The planner turns this policy information into proposed iptables rules.

[Here](https://github.com/cloudfoundry/silk-release/blob/develop/src/vxlan-policy-agent/planner/planner_linux.go#L297-L304) the VPA goes through all of the source apps and creates mark rules for them

[Here](https://github.com/cloudfoundry/silk-release/blob/develop/src/lib/rules/rules.go#L100-L105) is the implementation of *NewMarkSetRule*

üôè _If this story needs to be updated: please, please, PLEASE submit a PR. Amelia will be eternally grateful. How? Go to [this repo](https://github.com/pivotal/cf-networking-program-onboarding). Search for the phrase you want to edit. Make the fix!_","c2c,questions"
Container to Container Networking - Extra Credit - What is mark?,feature,"## Assumptions
- You have done the other stories in this track

## What
You may have noticed a discrepancy in the diagram and the steps about _where_ the mark is located. In the diagram it shows the mark on the _underlay_ packet. But the steps say that the _overlay_ packet is marked. Also the iptables rules seem to add the mark to the _overlay_ packet. So which is it? Well, both, kind of.

**The mark for the overlay packet is _not_ part of the packet itself.** This mark is just a bit of metadata about the packet that the kernel keeps track of. This mark exists only as long as it's handled by the Linux kernel. So if a packet is marked before it is sent to a different host, the host will not receive the mark information.

**When VTEP on the source host encapsulates the overlay packet, the mark gets recorded as a header in the underlay packet.** When the VTEP on the destination host decapsulates the underlay packet, it sets the mark on the kernel for the overlay packet.

üôè _If this story needs to be updated: please, please, PLEASE submit a PR. Amelia will be eternally grateful. How? Go to [this repo](https://github.com/pivotal/cf-networking-program-onboarding). Search for the phrase you want to edit. Make the fix!_",c2c
Container to Container Networking - Part 3.1 - Linux Routes Table Primer,feature,"## Assumptions
- You have an OS CF deployed
- You have done the other stories in this track
- You have two [proxy](https://github.com/cloudfoundry/cf-networking-release/tree/develop/src/example-apps/proxy) apps pushed and named appA and appB (the fewer apps you have deployed the better)

## Review
This track of stories is going to go through the steps (listed below) that were covered in the dataflow overview.
The steps and diagram will be at the top of each story in case you need to orient yourself. Higher quality diagram [here](https://storage.googleapis.com/cf-networking-onboarding-images/c2c-data-plane.png).

![c2c traffic flow](https://storage.googleapis.com/cf-networking-onboarding-images/overlay-underlay-silk-network.png)

1. AppB (on Diego Cell 1) makes a request to AppA's overlay IP address (on Diego Cell 2). This packet is called the overlay packet (aka the c2c packet).
1. The packet exits the app container through the veth interface.
1. **The overlay packet is marked with a ...mark... that is unique to the source app.
1. **Because the packet is an overlay packet, it is sent to the silk-vtep interface on the Diego Cell. This interface is a VXLAN interface.   <------- CURRENT STORY**
1. The overlay packet is encapsulated inside of an underlay packet. This underlay packet is addressed to underlay IP of the Diego Cell where the destination app is located (appA in this case).
1. The underlay packet exits the cell.
1. The packet then travels over the physical underlay network to the correct Diego Cell.
1. The packet arrives to the correct Diego Cell
1. The underlay packet is decapsulated. Now it's just the overlay packet again.
1. Iptables rules check that appA is allowed to talk to appB based on the mark on the overlay packet.
1. If traffic is allowed, the overlay network directs the traffic to the correct place.

## What

In order for all overlay packets to be sent to the correct interface, the linux routes table needs to be configured correctly. But, what is a linux routes table?

## How

1. üé•I couldn't find a good blog post to read. So instead I found a youtube video. Watch [this](https://www.youtube.com/watch?v=g8eP4fhrx3I) video.

### Expected Outcome
You understand the basics of a route table.

üôè _If this story needs to be updated: please, please, PLEASE submit a PR. Amelia will be eternally grateful. How? Go to [this repo](https://github.com/pivotal/cf-networking-program-onboarding). Search for the phrase you want to edit. Make the fix!_",c2c
Container to Container Networking - Part 3.2 - Diego Cell Routes Table,feature,"## Assumptions
- You have an OS CF deployed
- You have done the other stories in this track
- You have two [proxy](https://github.com/cloudfoundry/cf-networking-release/tree/develop/src/example-apps/proxy) apps pushed and named appA and appB (the fewer apps you have deployed the better)

## Review
This track of stories is going to go through the steps (listed below) that were covered in the dataflow overview.
The steps and diagram will be at the top of each story in case you need to orient yourself. Higher quality diagram [here](https://storage.googleapis.com/cf-networking-onboarding-images/c2c-data-plane.png).

![c2c traffic flow](https://storage.googleapis.com/cf-networking-onboarding-images/overlay-underlay-silk-network.png)

1. AppB (on Diego Cell 1) makes a request to AppA's overlay IP address (on Diego Cell 2). This packet is called the overlay packet (aka the c2c packet).
1. The packet exits the app container through the veth interface.
1. **The overlay packet is marked with a ...mark... that is unique to the source app.
1. **Because the packet is an overlay packet, it is sent to the silk-vtep interface on the Diego Cell. This interface is a VXLAN interface.   <------- CURRENT STORY**
1. The overlay packet is encapsulated inside of an underlay packet. This underlay packet is addressed to underlay IP of the Diego Cell where the destination app is located (appA in this case).
1. The underlay packet exits the cell.
1. The packet then travels over the physical underlay network to the correct Diego Cell.
1. The packet arrives to the correct Diego Cell
1. The underlay packet is decapsulated. Now it's just the overlay packet again.
1. Iptables rules check that appA is allowed to talk to appB based on the mark on the overlay packet.
1. If traffic is allowed, the overlay network directs the traffic to the correct place.

## What

In the last story, you were introduced to what a routes table is. In this story we are going to look at the routes table on a Diego Cell and decipher what is there.

There are two easy ways to look at the route table. The old way is `route -n`, which displays the information nicely with headers. The new way is `ip route` which displays the information with no headers to make scripting easier. This story is going to use `route -n` because headers are good.

## How

üìù **Look at routes table**
1. Ssh onto the Diego Cell where appA is running and become root.
1. Look at the routes table
 ```
route -n
 ```

Below is the output from a Diego Cell with two apps running on it. The output is split so we can look at it one section at a time.
The output has been condensed for clarity and brevity.

‚¨áÔ∏èThis is the default rule that sends traffic to eth0 by default
```
Destination     Gateway         Genmask         Iface
0.0.0.0         10.0.0.1        0.0.0.0         eth0
```

‚¨áÔ∏èThis is the rule that sends all overlay traffic to the silk-vtep interface. (This is the key bit to this story!)
```
Destination     Gateway         Genmask         Iface
10.255.0.0      0.0.0.0         255.255.0.0     silk-vtep
```

‚¨áÔ∏èThis is the overlay IP range for the other Diego Cell on the network. (We'll talk more about this in a later story.)
```
Destination     Gateway         Genmask         Iface
10.255.82.0     10.255.82.0     255.255.255.0   silk-vtep
```

‚¨áÔ∏èThese are istio routers, which are also on the overlay network. If you don't have istio-release deployed, you won't see these.
These are not important for this onboarding.
```
Destination     Gateway         Genmask         Iface
10.255.0.160    10.255.0.160    255.255.255.255 silk-vtep
10.255.0.225    10.255.0.225    255.255.255.255 silk-vtep
```

‚¨áÔ∏èThese are the apps running on this Diego Cell. The interface is the host side of the veth pair.
```
Destination     Gateway         Genmask         Iface
10.255.77.3     0.0.0.0         255.255.255.255 s-010255077003
10.255.77.4     0.0.0.0         255.255.255.255 s-010255077004
```

### Expected Outcome
You look at the routes table on a Diego Cell and can decipher what you see.

üôè _If this story needs to be updated: please, please, PLEASE submit a PR. Amelia will be eternally grateful. How? Go to [this repo](https://github.com/pivotal/cf-networking-program-onboarding). Search for the phrase you want to edit. Make the fix!_",c2c
Container to Container Networking - Part 4.1 - VLAN VXLAN VTEP V-What?,feature,"## Assumptions
- None

## What
In the explanation of the data flow for container to container (c2c) networking, step 4 says: *Because the packet is an overlay packet, it is sent to the silk-vtep interface on the Diego Cell. This interface is a VXLAN interface. *

What does that even mean!??!!?
Let's define some terms.

**LAN** - Local Area Network - a small network that is usually for connecting personal computers. Each computer in a LAN is able to access data and devices anywhere on the LAN. This means that many users can share devices, such as laser printers, as well as data. ([paraphrased from here](https://www.webopedia.com/TERM/L/local_area_network_LAN.html)). Often, used by gamers in [LAN parties](https://en.wikipedia.org/wiki/LAN_party) and by offices.

**VLAN** - Virtual Local Area Network - a network that *appears* to be on the same LAN, even though the machines are physically separated. For example, the Pivotal LA and SF (and probably other west coast offices) are on the same VLAN. This allows Pivots in these offices to SSH onto other machines in the VLAN. But those outside of the VLAN cannot SSH onto machines inside of the VLAN.

**VXLAN** - Virtual eXtensible Local Area Network - VXLAN was developed to provide the same network services as VLAN does, but with greater extensibility and flexibility. Container to container (c2c) networking uses VXLAN to create the overlay network.

**VTEP**- VXLAN Tunnel EndPoints - are VXLAN tunnels that encapsulate outgoing overlay traffic into underlay packets and decapsulate incoming underlay packets into overlay packets. The VTEP that c2c uses is called silk-vtep.

## Resources
[LAN](https://www.webopedia.com/TERM/L/local_area_network_LAN.html)
[VLAN wiki](https://en.wikipedia.org/wiki/Virtual_LAN)
[VLAN vs VXLAN](http://www.fiber-optic-transceiver-module.com/vxlan-vs-vlan-which-is-best-fit-for-cloud.html)

üôè _If this story needs to be updated: please, please, PLEASE submit a PR. Amelia will be eternally grateful. How? Go to [this repo](https://github.com/pivotal/cf-networking-program-onboarding). Search for the phrase you want to edit. Make the fix!_",c2c
Container to Container Networking - Part 4.2 - Overlay Leases and ARP,feature," ## Assumptions
- You have an OS CF deployed
- You have done the other stories in this track
- You have two [proxy](https://github.com/cloudfoundry/cf-networking-release/tree/develop/src/example-apps/proxy) apps pushed and named appA and appB (the fewer apps you have deployed the better)

## Review
This track of stories is going to go through the steps (listed below) that were covered in the dataflow overview.
The steps and diagram will be at the top of each story in case you need to orient yourself. Higher quality diagram [here](https://storage.googleapis.com/cf-networking-onboarding-images/c2c-data-plane.png).

![c2c traffic flow](https://storage.googleapis.com/cf-networking-onboarding-images/overlay-underlay-silk-network.png)

1. AppB (on Diego Cell 1) makes a request to AppA's overlay IP address (on Diego Cell 2). This packet is called the overlay packet (aka the c2c packet).
1. The packet exits the app container through the veth interface.
1. The overlay packet is marked with a ...mark... that is unique to the source app.
1. Because the packet is an overlay packet, it is sent to the silk-vtep interface on the Diego Cell. This interface is a VXLAN interface.
1. **The overlay packet is encapsulated inside of an underlay packet. This underlay packet is addressed to the underlay IP of the Diego Cell where the destination app is located (appA in this case).    <------- CURRENT STORY**
1. The underlay packet exits the cell.
1. The packet then travels over the physical underlay network to the correct Diego Cell.
1. The packet arrives to the correct Diego Cell
1. The underlay packet is decapsulated. Now it's just the overlay packet again.
1. Iptables rules check that appA is allowed to talk to appB based on the mark on the overlay packet.
1. If traffic is allowed, the overlay network directs the traffic to the correct place.

## What

In the last story we learned that the VTEP is responsible for encapsulating the overlay packet and sending it to the correct Diego Cell. But how does it get that information?

Each CF Deployment is given a [range of IPs](https://github.com/cloudfoundry/silk-release/blob/develop/jobs/silk-controller/spec#L30-L33) to act as the overlay IPs. By default the overlay range is `10.255.0.0/16`. This is CIDR (pronounced, cider) notation for the IPs that range from 10.255.0.0 to 10.255.255.255. Every Diego Cell is given a subset of this range to give to the apps.

The Silk Controller is a database backed process that keeps track of which subnet of IPs is leased out to which Diego Cell. Every Diego Cell has a process running called the Silk Daemon, which constantly polls the Silk Controller and asks: ""what overlay ranges map to what Diego Cells""? The Silk Daemon then writes that information to the Address Resolution Protocol (ARP) table.

ARP is at layer 2 in the OSI (Open System Interconnection) model. If you haven't heard of OSI, read [this](https://www.webopedia.com/quick_ref/OSI_Layers.asp) as a primer. The main bit, is that at layer 2 [MAC addresses](https://whatismyipaddress.com/mac-address) are used to address data. Because of this, in the ARP table and in the silk database, the Diego Cells are referenced by their MAC addresses and not their underlay IPs. If you aren't familiar with OSI or MAC addresses, read those links before continuing on.

In this story, you are going to look at the Silk Controller database to see what overlay subnet is leased to which Diego Cells. Then you'll going to look at the ARP table.

## How

ü§î **Look at silk controller database**

1. Get the mysql username and password for the silk controller db. Download your bosh manifest and see what is set for the properties: `silk-controller.properties.database.name` and `silk-controller.properties.database.password`. You might need to look up these values in credhub. This will differ based on your deployment.
1. Bosh ssh onto the database VM and become root.
1. Login to your database. For a pxc-mysql deployment, it looks like this
 ```
/var/vcap/packages/pxc/bin/mysql -u network_connectivity -p -h sql-db.service.cf.internal -D DATABASE_NAME
 ```
1. Run the following query to look at all of the subnets.
 ```
mysql> select * from subnets;
+----+---------------+---------------------------+-----------------------------+------------------+
| id | underlay_ip   | overlay_subnet            | overlay_hwaddr              | last_renewed_at  |
+----+---------------+---------------------------+-----------------------------+------------------+
|  0 | DIEGO_CELL_IP | DIEGO_CELL_OVERLAY_SUBNET | DIEGO_CELL_VTEP_MAC_ADDRESS | TIMESTAMP        |
|  1 | 10.0.1.12     | 10.255.77.0/24            | ee:ee:0a:ff:4d:00           | 1555520514       | <--- Let's call these values: DIEGO_CELL_0_IP, DIEGO_CELL_0_OVERLAY_SUBNET, DIEGO_CELL_0_VTEP_MAC_ADDRESS
|  2 | 10.0.1.13     | 10.255.82.0/24            | ee:ee:0a:ff:52:00           | 1555520512       | <--- Let's call these values: DIEGO_CELL_1_IP, DIEGO_CELL_1_OVERLAY_SUBNET, DIEGO_CELL_1_VTEP_MAC_ADDRESS
|  3 | 10.0.1.17     | 10.255.0.225/32           | ee:ee:0a:ff:00:e1           | 1555520513       | <--- This is an istio router, which is also on the overlay. Each istio router gets one overlay IP. You might or might not have these.
|  4 | 10.0.1.18     | 10.255.0.160/32           | ee:ee:0a:ff:00:a0           | 1555520515       | <--- Another istio router.
+----+---------------+---------------------------+-----------------------------+------------------+
```

üìù**Look at the arp table**

1. Ssh onto the Diego Cell with DIEGO_CELL_0_IP as the underlay IP and become root.
1. Find the mac address of the silk-vtep interface
 ```
ip link show silk-vtep <---- Should match DIEGO_CELL_0_VTEP_MAC_ADDRESS
 ```

1. Look at the ARP table. This is how the VXLAN VTEP knows where each Diego Cell is located.
 ```
 arp
 ```
 You should see something like this. The output is split up so we can look at it section by section. Yours might be in a different order.

‚¨áÔ∏èThis is the entry for the other Diego Cell. This should match DIEGO_CELL_1_OVERLAY_SUBNET and DIEGO_CELL_1_VTEP_MAC_ADDRESS.
 ```
Address                  HWtype  HWaddress           Flags Mask            Iface
10.255.82.0              ether   ee:ee:0a:ff:52:00   CM                    silk-vtep
 ```

‚¨áÔ∏èThis is the entry for the Istio Routes. You might or might not have these. The MAC address and overlay ips should match the database.
 ```
Address                  HWtype  HWaddress           Flags Mask            Iface
10.255.0.225             ether   ee:ee:0a:ff:00:e1   CM                    silk-vtep
10.255.0.160             ether   ee:ee:0a:ff:00:a0   CM                    silk-vtep
 ```

‚¨áÔ∏èThis is the entries for the 2 apps running on this cell. The addresses match the overlay IPs of the two apps.
 ```
Address                  HWtype  HWaddress           Flags Mask            Iface
10.255.77.3              ether   ee:ee:0a:ff:4d:03   CM                    s-010255077003
10.255.77.4              ether   ee:ee:0a:ff:4d:04   CM                    s-010255077004
 ```

‚¨áÔ∏èThis is the entry for the eth0 interface.
 ```
Address                  HWtype  HWaddress           Flags Mask            Iface
10.0.0.1                 ether   42:01:0a:00:00:01   C                     eth0
 ```

## Resources
[The Layers of Networking - OSI](https://www.webopedia.com/quick_ref/OSI_Layers.asp)

üôè _If this story needs to be updated: please, please, PLEASE submit a PR. Amelia will be eternally grateful. How? Go to [this repo](https://github.com/pivotal/cf-networking-program-onboarding). Search for the phrase you want to edit. Make the fix!_",c2c
Container to Container Networking - Extra Credit - How are only some packets decapsulated?,feature,"## Assumptions
- You have completed the previous stories in this track
- You have one [proxy](https://github.com/cloudfoundry/cf-networking-release/tree/develop/src/example-apps/proxy) app pushed and called appA on Diego Cell 1
- You have one [proxy](https://github.com/cloudfoundry/cf-networking-release/tree/develop/src/example-apps/proxy) app pushed and called appB on Diego Cell 2

## What

So far the overlay packet has been encapsulated into an underlay packet and then it is sent to a second Diego Cell. Once the underlay packet gets to the Diego Cell it is gets decapsulated by the VTEP. But how does ""it"" know to send these specific underlay packets to the silk-vtep interface to be decapsulated and not other packets?

Let's figure it out by inspecting the packets with tcpdump! Tcpdump is a CLI tool that allows you to inspect all of the traffic flowing through your container.

### How

ü§î **Send traffic via the overlay from appA to appB**
1. In terminal 1, use watch to continuously curl appB from appA using appB's overlay IP and app port.

üìù **Look at the underlay traffic**
1. In terminal 2, ssh onto Diego Cell 2, where appB is running.
1. The underlay packet is from Diego Cell 1 to Diego Cell 2, so use tcpdump to look at all traffic from Diego Cell 1.
 ```
tcpdump -n src DIEGO_CELL_1_IP
 ```
‚ùìWhat do you notice about all of the traffic? What do they have in common? Based on this information how do you think only this traffic is being decapsulated?
‚ùìWhat protocol is this traffic using? Is that surprising to you?

### Expected outcome
You should see that all traffic to be decapsulated is sent to the same port. This is how some traffic is decapsulated by the VTEP but not others.

You should also notice that all of the traffic is sent via UDP. WHAT? Read [here](https://blog.ipspace.net/2012/01/vxlan-runs-over-udp-does-it-matter.html) for more details on _that_.

üôè _If this story needs to be updated: please, please, PLEASE submit a PR. Amelia will be eternally grateful. How? Go to [this repo](https://github.com/pivotal/cf-networking-program-onboarding). Search for the phrase you want to edit. Make the fix!_","c2c,questions"
Container to Container Networking - Part 5.1 - Enforce Policy,feature,"## Assumptions
- You have an OS CF deployed
- You have done the other stories in this track
- You have two [proxy](https://github.com/cloudfoundry/cf-networking-release/tree/develop/src/example-apps/proxy) apps pushed and named appA and appB (the fewer apps you have deployed the better)

## Review
This track of stories is going to go through the steps (listed below) that were covered in the dataflow overview.
The steps and diagram will be at the top of each story in case you need to orient yourself. Higher quality diagram [here](https://storage.googleapis.com/cf-networking-onboarding-images/c2c-data-plane.png).

![c2c traffic flow](https://storage.googleapis.com/cf-networking-onboarding-images/overlay-underlay-silk-network.png)

1. AppB (on Diego Cell 1) makes a request to AppA's overlay IP address (on Diego Cell 2). This packet is called the overlay packet (aka the c2c packet).
1. The packet exits the app container through the veth interface.
1. The overlay packet is marked with a ...mark... that is unique to the source app.
1. Because the packet is an overlay packet, it is sent to the silk-vtep interface on the Diego Cell. This interface is a VXLAN interface.
1. The overlay packet is encapsulated inside of an underlay packet. This underlay packet is addressed to the underlay IP of the Diego Cell where the destination app is located (appA in this case).
1. The underlay packet exits the cell.
1. The packet then travels over the physical underlay network to the correct Diego Cell.
1. The packet arrives to the correct Diego Cell
1. The underlay packet is decapsulated. Now it's just the overlay packet again.
1.  **Iptables rules check that appA is allowed to talk to appB based on the mark on the overlay packet.   <------- CURRENT STORY**
1. If traffic is allowed, the overlay network directs the traffic to the correct place.

## What

In the last story you learned how the VTEP is able to encapsulate overlay packets and send them to the correct Diego Cell via the underlay network.

Now that the packet has arrived at the correct Diego Cell, how is c2c policy enforced? (hint: iptables rules)

In this story, you are going to look at the iptables rules on the destination Diego Cell

## How
ü§î **Setup**
1. Make sure there are no c2c policies. (`cf network-policies --help`)

üìù**Look at iptables rules**
1. Ssh onto the Digeo Cell where appB is running and become root.
1. Look at the iptables rules on the filter table
 ```
iptables -S
 ```
You should see a chain that looks like the following
 ```
-N vpa--1555607784864807      <----------- Let's call this VPA_CHAIN_NAME
 ```
VPA stands for the VXLAN Policy Agent. The VPA is a component from silk-release that is responsible for translating the c2c policies in the database into iptables rules on the Diego Cell.
Any rules related to enforcing c2c policies will be on a custom chain that starts with ""vpa"".

1. Look at the rules on the vpa chain.
 ```
iptables -S VPA_CHAIN_NAME
 ```
 There's nothing there. No rules attached. That is because there are no c2c policies.

ü§î **Create c2c policy and look at iptables rules**
1. Create a c2c network policy from appA to appB (`cf add-network-policy --help`). The diagram in the review section shows apps on two different Diego Cell. The same iptables rules will be created and enforced regardless of whether appA and appB are on the same Diego Cell or not. A future story will go into more detail about this. But for this story, just know that it doesn't matter what Diego Cell your apps are running on.
1. On the Diego Cell, look at the rules on the vpa chain again.
 ```
iptables -S VPA_CHAIN_NAME
 ```
 What! you should get the error.`iptables: No chain/target/match by that name.`.
 When the VPA sees that it needs to update the iptables rules on a Diego Cell, it *doesn't* append new rules to existing chains. Instead, it replaces ALL OF THE RULES. When the VPA replaces all of the rules, the VPA chain get's renamed with a new timestamp.
1. Find the new name of the VPA chain.
1. Look at the rules on that chain.  They should look something like this
```
-N vpa--1555608460726256
-A vpa--1555608460726256 -s 10.255.77.3/32 -m comment --comment ""src:2f978b7f-b3d2-4f50-b08f-776634a6e411"" -j MARK --set-xmark 0x2/0xffffffff
-A vpa--1555608460726256 -d 10.255.77.4/32 -p tcp -m tcp --dport 8080 -m mark --mark 0x2 -m conntrack --ctstate INVALID,NEW,UNTRACKED -j LOG --log-prefix ""OK_0002_c7de6123-d906-4c65-9 ""
-A vpa--1555608460726256 -d 10.255.77.4/32 -p tcp -m tcp --dport 8080 -m mark --mark 0x2 -m comment --comment ""src:2f978b7f-b3d2-4f50-b08f-776634a6e411_dst:c7de6123-d906-4c65-9717-c5d040568c76"" -j ACCEPT
```

Let's look at them line by line.

‚¨áÔ∏èThis is adding the VPA chain
```
-N vpa--1555608460726256
```

‚¨áÔ∏èThis is about marking outgoing traffic. (We went over this in the story *Container to Container Networking - Part 2 - Marks*). You might not have this rule. You will only have this rule if this app is also the source of a networking policy.
```
-A vpa--1555608460726256 -s 10.255.77.3/32 -m comment --comment ""src:2f978b7f-b3d2-4f50-b08f-776634a6e411"" -j MARK --set-xmark 0x2/0xffffffff
```

‚¨áÔ∏èThis is about logging when traffic hits this rule. Your deployment might have logging turned off, so this rule might or might not be present. A future story will go more into this.
```
-A vpa--1555608460726256 -d 10.255.77.4/32 -p tcp -m tcp --dport 8080 -m mark --mark 0x2 -m conntrack --ctstate INVALID,NEW,UNTRACKED -j LOG --log-prefix ""OK_0002_c7de6123-d906-4c65-9 ""
```

‚¨áÔ∏èTHIS IS THE RULES THAT ENFORCES C2C POLICY!!!!
```
-A vpa--1555608460726256 -d 10.255.77.4/32 -p tcp -m tcp --dport 8080 -m mark --mark 0x2 -m comment --comment ""src:2f978b7f-b3d2-4f50-b08f-776634a6e411_dst:c7de6123-d906-4c65-9717-c5d040568c76"" -j ACCEPT
```
‚ùìCan you rewrite this rule in sentence form to explain what it is checking?

### Expected Results
 You can find and understand the iptables rule that enforces c2c policy.

## Resources
[iptables man page](http://ipset.netfilter.org/iptables.man.html)
[Aidan's iptables in CF ppt](https://docs.google.com/presentation/d/1qLkNu633yLHP5_S_OqOIIBETJpW3erk2QuGSVo71_oY/edit#slide=id.p)

üôè _If this story needs to be updated: please, please, PLEASE submit a PR. Amelia will be eternally grateful. How? Go to [this repo](https://github.com/pivotal/cf-networking-program-onboarding). Search for the phrase you want to edit. Make the fix!_","c2c,questions"
Container to Container Networking - Part 5.2 - Enforce Policy - Same Cell vs Different Cell,feature,"## Assumptions
- You have an OS CF deployed
- You have done the other stories in this track
- You have two [proxy](https://github.com/cloudfoundry/cf-networking-release/tree/develop/src/example-apps/proxy) apps pushed and named appA and appB (the fewer apps you have deployed the better)

## Review
This track of stories is going to go through the steps (listed below) that were covered in the dataflow overview.
The steps and diagram will be at the top of each story in case you need to orient yourself. Higher quality diagram [here](https://storage.googleapis.com/cf-networking-onboarding-images/c2c-data-plane.png).

![c2c traffic flow](https://storage.googleapis.com/cf-networking-onboarding-images/overlay-underlay-silk-network.png)

1. AppB (on Diego Cell 1) makes a request to AppA's overlay IP address (on Diego Cell 2). This packet is called the overlay packet (aka the c2c packet).
1. The packet exits the app container through the veth interface.
1. The overlay packet is marked with a ...mark... that is unique to the source app.
1. Because the packet is an overlay packet, it is sent to the silk-vtep interface on the Diego Cell. This interface is a VXLAN interface.
1. The overlay packet is encapsulated inside of an underlay packet. This underlay packet is addressed to the underlay IP of the Diego Cell where the destination app is located (appA in this case).
1. The underlay packet exits the cell.
1. The packet then travels over the physical underlay network to the correct Diego Cell.
1. The packet arrives to the correct Diego Cell
1. The underlay packet is decapsulated. Now it's just the overlay packet again.
1.  **Iptables rules check that appA is allowed to talk to appB based on the mark on the overlay packet.   <------- CURRENT STORY**
1. If traffic is allowed, the overlay network directs the traffic to the correct place.

## What

The diagram above shows the container to container networking traffic flow between two apps on different Diego Cells. But what about when the apps are on the same Diego Cell?

In this story, you are going to do some investigation to figure out what the container to container traffic flow is for apps on the same Diego Cell.

## Questions

To answer these questions, it might be helpful to review [Aidan's iptables in CF ppt](https://docs.google.com/presentation/d/1qLkNu633yLHP5_S_OqOIIBETJpW3erk2QuGSVo71_oY/edit#slide=id.p).

‚ùìWhat chain (INPUT, OUTPUT, or FORWARD) are the container networking policy iptables rules appended to?
‚ùìDoes overlay traffic between apps on different Diego Cells hit this chain?
‚ùìDoes overlay traffic between apps on the same Diego Cell hit this chain?
‚ùìDoes overlay traffic between apps on the same Diego Cell get encapsulated?
‚ùìWhat steps listed in the review section apply for apps on the same Diego Cell?

## Expected Result

At the end of this story, you should know the traffic flow between two apps on the same Diego Cell.

## Resources
[Aidan's iptables in CF ppt](https://docs.google.com/presentation/d/1qLkNu633yLHP5_S_OqOIIBETJpW3erk2QuGSVo71_oY/edit#slide=id.p)

üôè _If this story needs to be updated: please, please, PLEASE submit a PR. Amelia will be eternally grateful. How? Go to [this repo](https://github.com/pivotal/cf-networking-program-onboarding). Search for the phrase you want to edit. Make the fix!_","c2c,questions"
Logging with Container to Container Networking,feature,"## Assumptions
- You have an OS CF deployed
- You have two [proxy](https://github.com/cloudfoundry/cf-networking-release/tree/develop/src/example-apps/proxy) apps pushed and named appA and appB (the fewer apps you have deployed the better)
- There are no c2c policies

## What

When you use c2c policies you have the option of logging every time that one app attempts to send traffic to another app.

In this story you will learn (1) how to turn on this feature, (2) how to look at the logs, and (3) how this feature is implemented (hint: iptables).

## How

ü§î **Turn on logging**
1. Follow [these instructions](https://github.com/cloudfoundry/silk-release/blob/77ecbb775780d74c5a8b6e87c5554dab375a9235/docs/traffic_logging.md#traffic-logging) to enable c2c policy logging _AND_ ASG logging. (There is a bug where you need to enable both in order for c2c logging to work. Maybe you could be the one who fixes it?)

üìù **Look at logs**
1. In one terminal, Ssh onto the Diego Cell where appB is running and become root.
1. Watch the kern.logs (kern stands for kernel, as in the linux kernel).
 ```
tail -f kern.log
 ```
1. In another terminal, curl appB from appA. You should see log line similar to the one below.

 ```
2019-04-18T18:01:05.306552+00:00 localhost kernel: [22246.987902]
DENY_C2C_f13ffea0-9d0d-4ee9-                   <----- DENY means that the traffic was blocked by iptables rules. The GUID here is the beginning of the instance GUID that we have seen before.
IN=s-010255077003                              <----- The interface of the source app (This seems backwards given that this is IN, I'm not sure why this is).
OUT=s-010255077004                             <----- The interface of the destination app (This seems backwards given that this is OUT, I'm not sure why this is).
MAC=aa:aa:0a:ff:4d:03:ee:ee:0a:ff:4d:03:08:00  <----- This is a combination of the mac address of the source app's container network interface and the mac address of the source Diego Cell's VTEP.
SRC=10.255.77.3                                <----- The overlay IP of the source app
DST=10.255.77.4                                <----- The overlay IP of the destination app
LEN=60 TOS=0x00 PREC=0x00 TTL=63 ID=12504 DF PROTO=TCP SPT=39304 DPT=8080 WINDOW=27400 RES=0x00 SYN URGP=0
 ```

1. Add network policy from appA to appB (`cf add-network-policy --help`)
1. Curl appB from appA again. You should see log line similar to the one below (it's very similar to the one above).
 ```
2019-04-18T18:21:00.670494+00:00 localhost kernel: [23442.243710]
OK_0002_c7de6123-d906-4c65-9               <----- OK means that the traffic was allowed by iptables rules.
IN=s-010255077003
OUT=s-010255077004
MAC=aa:aa:0a:ff:4d:03:ee:ee:0a:ff:4d:03:08:00
SRC=10.255.77.3
DST=10.255.77.4
LEN=60 TOS=0x00 PREC=0x00 TTL=63 ID=35333 DF PROTO=TCP SPT=41330 DPT=8080 WINDOW=27400 RES=0x00 SYN URGP=0
MARK=0x2                    <----- Successful logs also include the mark of the source app.
 ```

ü§î **Find the implementation**
1. Look at the iptables rules on the Diego Cell
1. Find the rule that logs c2c traffic.

### Expected Result

You (1) turned on this feature, (2) looked at the logs, and (3) saw how this feature is implemented with iptables rules.

## Resources
[Traffic Logging with Silk Release](https://github.com/cloudfoundry/silk-release/blob/77ecbb775780d74c5a8b6e87c5554dab375a9235/docs/traffic_logging.md#traffic-logging)

üôè _If this story needs to be updated: please, please, PLEASE submit a PR. Amelia will be eternally grateful. How? Go to [this repo](https://github.com/pivotal/cf-networking-program-onboarding). Search for the phrase you want to edit. Make the fix!_",c2c
Watch your c2c packets with tcpdump,feature,"## Assumptions
- You have a CF deployed
- You have two [proxy](https://github.com/cloudfoundry/cf-networking-release/tree/develop/src/example-apps/proxy) apps pushed and called appA and appB
- There are no c2c network policies

### What?
Sometimes a user comes to us and says ""container to container networking is broken! AppA can't talk to AppB"". After making sure that they have c2c policies set, the next thing you might do is use tcpdump.

Tcpdump is a CLI tool that allows you to inspect all of the traffic flowing through your container.

In this story we are going to look at the packets being sent from AppA to AppB. Then we'll watch the packets being sent in response!

### How?

üìù **Curl appB from appA**
1. Get the overlay IPs of appA and appB
1. Continually try to curl appB from appA
 ```
watch -n 15 curl APP_A_ROUTE/proxy/APP_B_OVERLAY_IP:8080
 ```

üìù **Look at those packets**
1. In another terminal, ssh onto the Diego Cell where appA is running and become root
1. Run `tcpdump`.
    Ahhhhh too much information! ctrl+c! ctrl+c!  On a Diego Cell there are many packets being sent around, and tcpdump gives information about ALL OF THEM. We need to figure out a way to filter this overwhelming stream of information.
1.  Filter by packets where the source IP is APP_A_OVERLAY_IP and where the destination IP is APP_B_OVERLAY_IP.
 ```
tcpdump -n src APP_A_OVERLAY_IP and dst APP_B_OVERLAY_IP
 ```

 You should see something like:
 ```
$ tcpdump -n src 10.255.77.3 and dst 10.255.77.4
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth0, link-type EN10MB (Ethernet), capture size 262144 bytes
 ```

 ...and nothing else. Where are those packets?
 Notice that tcpdump is looking for packets listening on the eth0 interface. That's not where overlay packets go!

1. Look for packets on any interface
 ```
tcpdump -n src APP_A_OVERLAY_IP and dst APP_B_OVERLAY_IP -i any
 ```
 Hey! Those are packets!

 Record the packets you see here from one curl.
 ```
# PUT TCPDUMP OUTPUT HERE
 ```

 If appB was successfully responding, then you should also see packets being sent in the opposite direction.

1. See that no packets are being sent from AppB to AppA
  ```
tcpdump -n src APP_B_OVERLAY_IP and dst APP_A_OVERLAY_IP -i any
 ```

ü§î **Add c2c policy**
1. Add c2c policy to allow traffic from appA to appB (`cf add-network-policy --help`)
1. Continually try to curl appB from appA

üìù **Look at those packets**
1. Look for packets from appA to appB
 ```
tcpdump -n src APP_A_OVERLAY_IP and dst APP_B_OVERLAY_IP -i any
 ```
 Record the packets you see here from one curl.

 ```
 PUT TCPDUMP OUTPUT HERE
 ```
‚ùìHow are these packets different from before?

1. Look for packets from appB to appA
 ```
tcpdump -n src APP_B_OVERLAY_IP and dst APP_A_OVERLAY_IP -i any
 ```

### Expected Result

You should see packets being sent in response from appB to appA. You should see `200 OK`.

### Resources
[tcpdump man page](https://www.tcpdump.org/manpages/tcpdump.1.html)
[helpful common tcpdump commands](https://www.rationallyparanoid.com/articles/tcpdump.html)
[debugging non-c2c traffic in CF](https://github.com/cloudfoundry/cf-networking-release/blob/develop/docs/troubleshooting.md#debugging-non-c2c-packets)

üôè _If this story needs to be updated: please, please, PLEASE submit a PR. Amelia will be eternally grateful. How? Go to [this repo](https://github.com/pivotal/cf-networking-program-onboarding). Search for the phrase you want to edit. Make the fix!_","c2c,questions"
Bypass container networking policies,feature,"## Assumptions
- You have a OSS CF deployed
- You have two [proxy](https://github.com/cloudfoundry/cf-networking-release/tree/develop/src/example-apps/proxy) apps pushed and named appA and appB
- You have at least 2 Diego Cells
- There are no c2c network policies

## What

Before container networking and the overlay network, apps could talk to each other via the backend IP and port.

The old workflow was:
1. Create an ASG that allows apps to send traffic to the Diego Cell IPs
1. Bind that ASG to appA
1. AppA discovers appB's backend IP and port.
1. AppA sends traffic to appB.

Turns out that old workflow still (kind of) works. Even worse, some CF users still rely on this behavior! Fun!

In this story you are going to see when this workflow does and doesn't work and why.

## How
ü§î **Get Diego Cell IPs**
1. Get and record the following variables:
 ```
DIEGO_CELL_1_IP = ...
DIEGO_CELL_2_IP = ...
 ```

ü§î **Create a wide open ASG**
1. Create an ASG that allows traffic to DIEGO_CELL_1_IP and DIEGO_CELL_2_IP
1. Bind that ASG to appA.
1. Restart appA

ü§î **Setup**
1. Scale appB to 2 instances.
1. Make sure that you have the following configuration.
 - Diego Cell 1: 1 instance of appA, 1 instance of appB (appB_1)
 - Diego Cell 2: 1 instance of appB, this instance will be called appB_2

ü§î **Get environment variables**
1. Get and record the following variables:
 ```
APP_B_1_BACKEND_PORT = ...
APP_B_2_BACKEND_PORT = ...
 ```
hint: you can ssh onto a specific instance of an app, by passing the `-i` flag (`cf ssh --help`).

üìù **Bypass c2c rules and route integrity**
1. Ssh onto appA
1. See if you can access appB
 ```
curl DIEGO_CELL_1_IP:APP_B_1_BACKEND_PORT
 ```

1. See if you can access appB
 ```
curl DIEGO_CELL_2_IP:APP_B_2_BACKEND_PORT
 ```

### Expected Result
AppA should not be able to access appB_1. AppA should be able to access appB_2.

## Questions

‚ùìWhy can appA access apps on other Diego Cells, but not on its own? (Hint: look at the iptables rules and review the diagrams in _Route Propagation - Part 5 - DNAT Rules_)
‚ùìDo you think this is a security concern?
‚ùìDo you think we should ""fix"" this? What would you suggest?

## Resources
[Aidan's iptables in CF ppt](https://docs.google.com/presentation/d/1qLkNu633yLHP5_S_OqOIIBETJpW3erk2QuGSVo71_oY/edit#slide=id.p)

üôè _If this story needs to be updated: please, please, PLEASE submit a PR. Amelia will be eternally grateful. How? Go to [this repo](https://github.com/pivotal/cf-networking-program-onboarding). Search for the phrase you want to edit. Make the fix!_","c2c,questions,questions"
Container to Container Networking ‚áß,release,,c2c
User Flow: Container to Container Networking with Service Discovery,feature,"## Assumptions
- You have a CF deployed with silk release
- You have appA  talking to appB via c2c networking and policy (see previous story ""User Flow Container to Container Networking"")

## What

In the previous story you were able to use c2c networking to get appA to talk directly to appB using the overlay IP for appB (explanation of what overlay is will come soon, I swear).

But IPs are ugly and URLs are pretty. Also, what happens when you restage an app? Also, how do I load balance across many instances when I can only use IPs?

In order to fix these problems, we implemented Service Discovery, which is apart of cf-networking-release. Service Discovery is also sometimes called app-sd. Service Discovery is a fancy way of saying we handle the URL -> IP translation for internal routes. Now appA can ""discover"" where the ""service"" appB is, without having to know the IP.

Service Discovery is implemented using ""internal routes"" these routes will *only* work from one CF app to another. They will not be accessible from clients outside of CF.

## How

1. Start off where you left off from the previous story ""User Flow Container to Container Networking""). You should have appA talking to appB via an overlay IP using `watch  ""curl CF_INSTANCE_INTERNAL_IP:8080""` inside of the appA container in one terminal. 

1. In another terminal, run `cf restart appB`
   Predictably, the curl from appA to appB fails when appB is stopped. But it should come back when appB starts running again, right? ...Right? WHY IS IT STILL FAILING?

1. Recheck the overlay IP for appB `cf ssh appB -c ""env | grep CF_INSTANCE_INTERNAL_IP""`
   What?! It moved! Use this new overlay IP to curl appB from appA and see that it still works. Lesson learned: IPs suck. Let's use Service Discovery instead.

1. When you create a route, any route, you have to supply a domain. To create an internal route, it must use an internal domain. We'll get into why in another story. For now, run `cf domains` and see that you should have a domain (or two) that is labeled `internal`.  Note the name of an internal domain that DOES NOT CONTAIN THE WORD ""istio"". You probably have the internal domain ""apps.internal"". Let's use that. (If you don't have a non istio internal domain, follow the resource at the bottom of this story to add a custom internal domain).

1. Using `cf map-route`, create and map a route for appB that uses the domain ""apps.internal"". May I suggest the route, appB.apps.internal?

1. In the terminal that is in the container for appA, run `watch  ""curl appB.apps.internal:8080""`.

1. Restart appB.

1. Scale appB. Can you tell which instance you are hitting?

### Expected Result
Now that you are using internal routes to communicate via c2c, it shouldn't matter that appB is restarted. As long as appB is running, appA should be able to access it thanks to Service Discovery. When there are multiple instances of appB, the internal route will automatically load balance between all of the instances. 

## Resources

[internal domain docs](https://github.com/cloudfoundry/cf-networking-release/blob/develop/docs/app-sd.md#internal-domains)
[servide discovery docs](https://github.com/cloudfoundry/cf-networking-release/blob/develop/docs/app-sd.md)

üôè _If this story needs to be updated: please, please, PLEASE submit a PR. Amelia will be eternally grateful. How? Go to [this repo](https://github.com/pivotal/cf-networking-program-onboarding). Search for the phrase you want to edit. Make the fix!_","c2c-service-discovery,user-workflow"
User Flow: Create your own Internal Domain,feature,"## Assumptions
- You have a CF deployed with silk release
- You have appA  talking to appB via c2c networking and policy (see previous story ""User Flow: Container to Container Networking with Service Discovery"")

## What

In the previous story you created an internal route for appA to talk to appB using the domain ""apps.internal"", but what if we wanted to create our own internal domain (may I suggest meow.meow.meow)?

## How

1. Start off where you left off from the previous story ""User Flow Container to Container Networking""). You should have appA talking to appB via an overlay IP using `watch  ""curl appB.apps.internal:8080""` inside of the appA container in one terminal. 

1. In another terminal, create a new internal domain `cf create-shared-domain meow.meow.meow --internal`
   Check that it worked
   ```
$ cf domains
Getting domains in org o as admin...
name                         status   type   details
meow.meow.meow               shared          internal
   ```

1. Using `cf map-route`, create and map a route for appB that uses our new internal domain ""meow.meow.meow"". May I suggest the route, appB.meow.meow.meow?

1. In the terminal that is in the container for appA, use this new internal route to curl appB `watch ""curl -sS appB.meow.meow.meow:8080""`
    What? ""Could not resolve host""???? Why doesn't it work like our other internal route? Unlike other domains, internal domains require one more step in order for them to work.

1. Download the manifest for your CF. Look at the property `internal_domains` on the `bosh_dns_adapter` job. It probably looks like this:
   ```
internal_domains:
      - apps.internal.
   ```

   So unfortunately, there is a deploy time dependency for internal domains. I know, this makes me sad too. Let's dig in why this is.

   Warning, Architecture Description Ahead (please follow along with the diagram below): When an app makes ANY network request that requires DNS lookup (that is, any request to a URL, not an IP) , the DNS lookup first hits Bosh DNS. Bosh DNS then checks to see if the domain of the URL being requested matches any of the internal domains that it knows about from the Bosh DNS Adapter `internal_domains` property. There is no reason why this couldn't be dynamic, Bosh DNS Adapter *could* make an API call to CAPI to figure out what the up-to-date internal domains are. But it doesn't, so it's not dynamic. Then the Bosh DNS Adapter calls out to the Service Discovery Controller, which keeps track of what internal route maps to what overlay IP, very similar to the routes table in the GoRouter.

   ![href](https://github.com/cloudfoundry/cf-networking-release/blob/develop/docs/architecture-diagram.png?raw=true)

1. Add our internal domain meow.meow.meow to the bosh manifest.

1. Redeploy your environment.

1. In the terminal that is in the container for appA, use this new internal route to curl appB `watch ""curl -sS appB.meow.meow.meow:8080""`

### Expected Result

appA should be able to successfully reach appB using the internal route with our brand new internal domain.

## Resources

https://github.com/cloudfoundry/cf-networking-release/blob/develop/docs/app-sd.md#internal-domains
https://github.com/cloudfoundry/cf-networking-release/blob/develop/docs/app-sd.md

üôè _If this story needs to be updated: please, please, PLEASE submit a PR. Amelia will be eternally grateful. How? Go to [this repo](https://github.com/pivotal/cf-networking-program-onboarding). Search for the phrase you want to edit. Make the fix!_","c2c-service-discovery,user-workflow"
Break things with Internal Domains!,feature,"## Assumptions

## What
In the previous story (""User Flow: Create your own Internal Domain"") we talked about how Bosh DNS redirects all DNS lookups where the request matches an internal domain to the Bosh DNS Adapter. In this story we are going to exploit this.

   ![href](https://github.com/cloudfoundry/cf-networking-release/blob/develop/docs/architecture-diagram.png?raw=true)

## How

üòá **Pretend you are innocent user1**
1. Push [proxy app](https://github.com/cloudfoundry/cf-networking-release/tree/develop/src/example-apps/proxy) and call it appA.

1. Make sure appA has an http route, let's call it APPA_ROUTE.

1. From your terminal, use appA's `/proxy` endpoint to send traffic from appA to neopets.com
 ```
 watch ""curl -sS APPA_ROUTE/proxy/neopets.com""
 ```
 You should get back some html for neopets! Fun! :D

üòà **Now pretend you are malicious user2**
As a malicious actor, you know that appA is sending traffic to neopets.com. You want to break their app and make it so appA can't reach neopets. You can do this by shadowing the neopets.com domain with an internal domain. 

1. Create the internal domain `neopets.com` (look at `cf create-shared-domain --help` if you don't remember how)

  Instead of adding this new internal domain to the bosh manifest and redeploying, we are going to hack this in on the Diego Cell. This is a great, fast, (and dangerous) debugging technique. It should be used with heavy caution, but it is often the fastest way to change a bosh property if things are really bad and need to be fixed immediately.

1. Ssh onto the Diego Cell where appA is running and become root.

1. You need to find what config file holds the information you want to change. The config on the VMs does not directly match the bosh manifest. To find any config for any bosh job in CF go to `/var/vcap/jobs/JOB_NAME`. There are many files there for Bosh DNS Adapter. In order to figure out exactly what you need to change, look at [Bosh DNS Job in the release code](https://github.com/cloudfoundry/cf-networking-release/tree/develop/jobs/bosh-dns-adapter) and look where the `internal_domains` property is used. [hint](https://github.com/cloudfoundry/cf-networking-release/blob/develop/jobs/bosh-dns-adapter/templates/handlers.json.erb#L11). [hint](https://github.com/cloudfoundry/cf-networking-release/blob/develop/jobs/bosh-dns-adapter/spec#L10).

1. Edit the correct config file and add an entry for our new domain `neopets.com`. It should look exactly like `apps.internal` except for the name.

1. Now you'll need to restart the Bosh DNS Adapter process so that it will run with our new config. Linux Bosh VMs use monit as a process manager. Run `monit summary` to see all of the processes running on this VM. Restart the Bosh DNS Adapter by running `monit restart bosh-dns-adapter`. Keep running `monit summary` until the Bosh DNS Adapter is successfully running again. If it fails to start, then you probably made a syntax error in the config file. Look at the logs and fix the error.

üòá **Back to pretending you are innocent user1**
1. From your terminal, use appA's `/proxy` endpoint to send traffic from appA to neopets.com
   `watch ""curl -sS APPA_ROUTE/proxy/neopets.com""`
   It should still show neopets. Why isn't it broken yet!?

üòà **Now pretend you are malicious user2**
You restarted the Bosh DNS Adapter, but look at the diagram again. It's actually Bosh DNS _not_ Bosh DNS adapter that does the hairpinning for internal domains.
You had to restart Bosh DNS Adapter process so it would run with the new config file, but you also need to restart the Bosh DNS process, so it can get these new values from the Bosh DNS Adapter.
1. Restart Bosh DNS
 ```
 monit restart bosh-dns
 ```

üòá **Back to pretending you are innocent user1**
1. From your terminal, use appA's `/proxy` endpoint to send traffic from appA to neopets.com
   `watch ""curl -sS APPA_ROUTE/proxy/neopets.com""`
   Where did neopets go???

### Expected Result
AppA should no longer be able to access neopets. :(

## Questions

1. Neopets is a silly example. What is a worse example that customers could run into?
1. What permissions does a user require to exploit this?
1. Would you consider this a security concern?
1. Would your assessment change if internal domains were dynamic and didn't require setting a bosh property at deploy time? Why or why not?
1. What will happen to your config changes if you redeployed your environment?

## Resources
https://github.com/cloudfoundry/cf-networking-release/blob/develop/docs/app-sd.md#internal-domains
https://github.com/cloudfoundry/cf-networking-release/blob/develop/docs/app-sd.md

üôè _If this story needs to be updated: please, please, PLEASE submit a PR. Amelia will be eternally grateful. How? Go to [this repo](https://github.com/pivotal/cf-networking-program-onboarding). Search for the phrase you want to edit. Make the fix!_",c2c-service-discovery
Container to Container Networking with Service Discovery ‚áß,release,,c2c-service-discovery
Iptables - a primer,feature,"## What
ASGs and c2c network policies are implemented using iptables rules. Think of iptables as a firewall implementation. (Iptables can do more than firewall things, but we have to start somewhere.)

All network traffic on linux machines is evaluated against the iptables rules written on the machine. To organize these rules, there are tables and chains. Tables have chains and chains have rules. Users (that's you!) can create custom chains and rules for their own needs. Traffic hits different tables and chains depending on if the traffic is ingress, egress, or East/West.

Let's look at the anatomy of an iptables rule.

![iptables rule anatomy](https://deliveryimages.acm.org/10.1145/2070000/2062737/10822f2.png)

The example above can be translated as:
- (**table/chain**) For any traffic that is evaluated against the filter table on the INPUT chain...
- (**match**)...if that traffic is using the tcp protocol...
- (**match**)...and if that traffic is sending traffic to port 80...
- (**jump rule/target**) ... then ACCEPT that traffic.

Once a packet hits ACCEPT, then it stops evaluating in that table and chain. It would also stop if it hit a DROP or REJECT target.

In this story you are going to skim/read a couple great resources on iptables rules.

## How
1. Give the [iptables man page](http://ipset.netfilter.org/iptables.man.html) a skim. At least the description, targets, and tables sections. It leaves out a lot of commonly used features that are covered in [the iptables-extensions man page](http://ipset.netfilter.org/iptables-extensions.man.html).

1. Flip through [Aidan's ""iptables in Cloud Foundry"" powerpoint](https://docs.google.com/presentation/d/1qLkNu633yLHP5_S_OqOIIBETJpW3erk2QuGSVo71_oY/edit#slide=id.p)

1. Check out [Julian Evan's Blog on iptables](https://jvns.ca/blog/2017/06/07/iptables-basics/).

## Optional Videos
Here are some thorough videos on iptables rules. If you are the type of person who likes getting lots of information up front, watch them now. 
If you are the type of person who likes to experiment first, skip these videos and watch them after the next story. (Don't worry I'll remind you.)

1. üé¨ Watch this video [""iptables: Packet Processing"" by Dr. Murphy's Lectures](https://www.youtube.com/watch?v=yE82upHCxfU) _length 14:22_
1. üé¨ Watch this video [""iptables: Tables and Chains"" by Dr. Murphy's Lectures](https://www.youtube.com/watch?v=jgH976ymdoQ) _length 10:34_

## Resources
[iptables man page](http://ipset.netfilter.org/iptables.man.html)
[Aidan's iptables in CF ppt](https://docs.google.com/presentation/d/1qLkNu633yLHP5_S_OqOIIBETJpW3erk2QuGSVo71_oY/edit#slide=id.p)
[Julia Evans iptables basics](https://jvns.ca/blog/2017/06/07/iptables-basics/)
[""iptables: Packet Processing"" by Dr. Murphy's Lectures](https://www.youtube.com/watch?v=yE82upHCxfU)
[""iptables: Tables and Chains"" by Dr. Murphy's Lectures](https://www.youtube.com/watch?v=jgH976ymdoQ)

üôè _If this story needs to be updated: please, please, PLEASE submit a PR. Amelia will be eternally grateful. How? Go to [this repo](https://github.com/pivotal/cf-networking-program-onboarding). Search for the phrase you want to edit. Make the fix!_",iptables-primer
Write your own iptables DROP rule in a docker container,feature,"## Assumptions
- You have the docker CLI installed

### What?
Experiment with writing your own iptables rules within the safety of your own docker container.

### How?

üìù **Get your docker container setup**
0. Run an ubuntu docker container and attach to it: `docker run --privileged -it ubuntu bin/bash`
0. Set up the docker container
    ```
    apt-get update
    apt-get install iptables
    apt-get install curl
    ```

üìù **What's the current state of the world?**
0. Look at the default iptables rules `iptables -S`.
    It should look like this:
    ```
    -P INPUT ACCEPT
    -P FORWARD ACCEPT
    -P OUTPUT ACCEPT
    ```
   Input, forward, and output are all names of chains. Currently there are no rules attached to these chains. What beautiful empty chains! This means that traffic is not being restricted by iptables.

0. See that traffic is not being restricted. `curl google.com`.  It works!

üìù **Make your own DROP rule**
Let's make a rule to DROP all traffic from the container so that the curl will fail.

0. Make your own custom chain.
 ```
 iptables -N drop-everything
 ```
0. Append a rule to your chain.
 ```
 iptables -A drop-everything -j DROP
 ```
0. View your handiwork. Oooooh. Ahhhhhhh.
 ```
 iptables -S
 ```
0. See if you can still `curl google.com`. What! The curl still works!
   That's because currently nothing is hitting your rule. You need to attach your custom chain to the INPUT, FORWARD, and/or OUTPUT chain in order for traffic to hit it.

    The INPUT, FORWARD, and OUTPUT chains are hit in different situations. (See diagram below)
    - The INPUT chain is hit by ingress traffic (remember, the traffic is coming *in*).
    - The FORWARD chain is hit by East/West traffic (remember... idk for this one).
    - The OUTPUT chain is hit by egress traffic (remember, the traffic is *e*xiting the container and going *out*).

   ![iptables chains and tables diagram](https://storage.googleapis.com/cf-networking-onboarding-images/iptables-tables-and-chains-diagram.png)

0. The request to google is egress traffic, so we want to attach out custom chain to the OUTPUT chain.
 ```
 iptables -A OUTPUT -j drop-everything
 ```

0. See if you can still `curl google.com`. You should see the error `Could not resolve host: google.com`.
0. Delete all of the rules and the chain that you created.
   Before you can delete the chain itself, you need to delete the rules attached to it using the `-D` flag.
   ```
iptables -D EITHER-INPUT-FORWARD-OR-OUTPUT -j drop-everything
iptables -D drop-everything -j DROP
   ```
   Then you can delete the chain itself using the `-X` flag
   ```
iptables -X drop-everything
   ```

Don't leave your docker container yet! You're going to need it in the next story!

### Expected Result

You should know how to...
- add/remove a iptables chain on a particular table
- add/remove a rule to an iptables chain

### Resources
[iptables man page](http://ipset.netfilter.org/iptables.man.html)
[Julia Evans iptables basics](https://jvns.ca/blog/2017/06/07/iptables-basics/)
[Aidan's iptables ppt](https://docs.google.com/presentation/d/1qLkNu633yLHP5_S_OqOIIBETJpW3erk2QuGSVo71_oY/edit#slide=id.p)
[iptables primer](https://danielmiessler.com/study/iptables/)

üôè _If this story needs to be updated: please, please, PLEASE submit a PR. Amelia will be eternally grateful. How? Go to [this repo](https://github.com/pivotal/cf-networking-program-onboarding). Search for the phrase you want to edit. Make the fix!_",iptables-primer
Watch Iptables Videos,feature,"## Assumptions
- None!

### What?
If you haven't watched these videos yet, now is a great time. In the last story you had a chance to poke around with iptables. 
Now hopefully when you watch these videos the content will really stick because you are more familiar with the concepts.

### How?

1. üé¨ Watch this video [""iptables: Packet Processing"" by Dr. Murphy's Lectures](https://www.youtube.com/watch?v=yE82upHCxfU) _length 14:22_
1. üé¨ Watch this video [""iptables: Tables and Chains"" by Dr. Murphy's Lectures](https://www.youtube.com/watch?v=jgH976ymdoQ) _length 10:34_

üôè _If this story needs to be updated: please, please, PLEASE submit a PR. Amelia will be eternally grateful. How? Go to [this repo](https://github.com/pivotal/cf-networking-program-onboarding). Search for the phrase you want to edit. Make the fix!_",iptables-primer
Write your own iptables firewall in a docker container,feature,"## What

Make a super basic firewall for your docker container. This (extremely practical) firewall will only let egress traffic exit if it is going to neopets.com.

## How

ü§î **Make your own rule**
0. Make your own chain.
0. Attach rule to that chain that accepts traffic if it is sent to ip 23.96.35.235 (neopets!) port 80 using tcp.
0. Attach a rule to that chain that drops all other traffic.
0. Add a jump rule to either the OUTPUT, FORWARD, or INPUT chains so that the traffic exiting the docker container will hit your custom chain.
0. Curl google.com. Does it fail?
0. Curl 23.96.35.235:80. Does it succeed?
0. Curl http://neopets.com. Does it fail or succeed? Why?
0. Practice deleting chains and rules: delete all of the rules and chains that you created.

### Expected Result
Hopefully you realize by now that iptables rules are very powerful and very fun :D

‚ùìWhy didn't curling http://neopets.com work?

### Extra Credit
1. Use iptables rules to make it so you can curl neopets.com, but not google.com

## Resources
[iptables man page](http://ipset.netfilter.org/iptables.man.html)
[Julia Evans iptables basics](https://jvns.ca/blog/2017/06/07/iptables-basics/)
[iptables.info - great resource linked to in Julia's blog, but only available with the way back machine](https://web.archive.org/web/20180310124055/http://www.iptables.info/en/iptables-contents.html) 
[Aidan's iptables ppt](https://docs.google.com/presentation/d/1qLkNu633yLHP5_S_OqOIIBETJpW3erk2QuGSVo71_oY/edit#slide=id.p)
[iptables primer](https://danielmiessler.com/study/iptables/)

üôè _If this story needs to be updated: please, please, PLEASE submit a PR. Amelia will be eternally grateful. How? Go to [this repo](https://github.com/pivotal/cf-networking-program-onboarding). Search for the phrase you want to edit. Make the fix!_","iptables-primer,questions"
Iptables Primer ‚áß,release,,iptables-primer
User Workflow: Application Security Groups,feature,"## Assumptions
- You have a CF deployed
- You have one [proxy](https://github.com/cloudfoundry/cf-networking-release/tree/develop/src/example-apps/proxy) app pushed and named appA

## What?
Application Security Groups (ASGs) are a collection of egress (outbound) rules that specify the protocols, ports, and IP ranges where applications can send traffic. ASGs define rules that *allow* traffic. They are a whitelist, not a blacklist.
Diego Cells use these ASGs to filter and log outbound network traffic.

When applications are staging, there need to be ASGs permissive enough to allow download particular resources (for example: ruby gems for ruby apps).
After an application is running, devs often want the ASGs to be more restrictive and secure. To distinguish between these two different security
requirements, administrators can define different security groups for *staging* containers versus *running* containers.

To provide granular control when securing egress app traffic, an administrator can also assign security groups to apply across a CF deployment, or to specific spaces or orgs within a foundation.

### How?

üìù **Look at the defaults**
1. Look at all the security group CLI commands. The commands can be confusing; familiarize yourself with all of the commands available.
 ```
cf help -a | grep security-group
 ```
1. As admin view the list of security groups `cf security-groups`

 In most default OSS deployments there will be two ASGs: `public_networks` and `dns`. These default ASGs are bound (aka applied) to the entire foundation.

1. View the rules for the `public_networks` security group.
 ```
 cf security-group public_networks
 ```

The public_network ASG allows egress traffic to access the entire public internet, via every protocol.

ü§î **Using Running ASGs**
Because the wide open `public_networks` security group is bound to all running and staging contains for the entire foundation, your app should be able to connect to any website on the internet. Let's test this.
1. Ssh onto appA (`cf ssh --help`)
1. Curl www.neopets.com. Success!
1. Unbind the public_networks **running** security-group.
1. When you bind/unbind ASGs you will see this helpful tip `TIP: Changes will not apply to existing running applications until they are restarted.` So restart your app!
1. Ssh onto appA again
1. Curl www.neopets.com.

‚ùì What happened? Why did it fail?

ü§î **Using Staging ASGs**
1. Unbind the public_networks **staging** security-group.
1. Push a new proxy app, and name it appB.

‚ùì What happened? Why did it fail?

**Reset your ASGs**
1. Rebind public_networks to both running and staging containers.

### Expected Result
When you have public_networks bound to all staging and running containers your apps can access the entire internet!
When public_networks is not bound to running containers then your running apps cannot access the internet.
When public_networks is not bound to staging containers, then the staging container is not able to access the internet to install godep (for go apps) and other staging requirements, so `cf push` will fail.

#### Note:
If you're working with PCF Dev, you should see three security groups. One is named `all_pcfdev` which opens all egress traffic. Because of this security group, any other group is redundant.

## Resources
[Application Security Groups Documentation](https://docs.cloudfoundry.org/adminguide/app-sec-groups.html)
[Typical Application Security Groups](https://docs.cloudfoundry.org/adminguide/app-sec-groups.html#typical-groups)
[""Taking Security to the Next Level‚ÄîApplication Security Groups"" by Abby Kearns](https://blog.pivotal.io/pivotal-cloud-foundry/products/taking-security-to-the-next-level-application-security-groups)
[""Making sense of Cloud Foundry security group declarations"" by Sadique Ali](https://sdqali.in/blog/2015/05/21/making-sense-of-cloud-foundry-security-group-declarations/)

üôè _If this story needs to be updated: please, please, PLEASE submit a PR. Amelia will be eternally grateful. How? Go to [this repo](https://github.com/pivotal/cf-networking-program-onboarding). Search for the phrase you want to edit. Make the fix!_","asgs,user-workflow,questions"
Iptables Primer,feature,"Please go to the section labeled ""iptables-primer"" and complete those stories before moving on.",asgs
ASGs and Iptables,feature,"## Assumptions
- You have a CF deployed
- You have completed the iptables-primer track
- You have one [proxy](https://github.com/cloudfoundry/cf-networking-release/tree/develop/src/example-apps/proxy) app pushed and named appA (the fewer apps you have deployed the better)
- You have the public_networks security group bound to all running and staging containers

## What?
In the previous story ""User Workflow: Application Security Groups"" you learned what ASGs *are*, but how are they implemented under the hood?
(Hint: iptables)

Information about ASGs are stored in CAPI's database. When a container create is triggered (for example by a cf push), CAPI passes ASG information along to Diego (container scheduler). Diego then passes the ASG information along to Garden (the container creator), which passes it along to the container networking components. After this long journey, the container networking components turn this ASG information into iptables rules on the Diego Cells.

Iptables rules are a series of rules that network packets match against to decide whether that traffic is allowed or not. This is one way firewalls can be implemented.
ASGs are only concerned with egress traffic from CF apps to something external to the CF foundation (usually the internet).

The iptables man page is extremely helpful as a reference! Consult it if you have any questions throughout this story.

Let's investigate what iptables rules are created for the public_networks ASG.

## How?

üìù **Find the iptables rule for the public_networks ASG**
1. Look at the ASG public_networks
 ```
 cf security-group public_networks
 ```
 Note which IP ranges are specified. Save these rules somewhere accessible for future reference.
1. Ssh onto the Diego Cell where appA is running and become root.
 ```
 # First determine the IP of the Diego Cell
cf ssh appA  -c ""env | grep CF_INSTANCE_IP""

 # Look at bosh output to see which Diego Cell has that IP
bosh instances

 # Ssh on
bosh ssh diego-cell/DIEGO_CELL_INSTANCE_GUID
 ```
1. List all of the iptables rules on the filter table on the Diego Cell
 ```
 iptables -t filter -S
 ```

Yep. It's a lot. Take a deep breath. Read it line by line. I promise it will start to become comprehensible.

Remember those IP ranges that are in the public_networks security group?
If you search for one of them (ie. `0.0.0.0-9.255.255.255`) you should be able to find an iptables rule that looks something like this:

```
# If you have logging enabled
-A netout--772fbbd5-862a-4b3d-7 -m iprange --dst-range 0.0.0.0-9.255.255.255 -g netout--772fbbd5-862a-4--log

# If you don't have logging enabled
-A netout--772fbbd5-862a-4b3d-7 -m iprange --dst-range 0.0.0.0-9.255.255.255 -j ACCEPT
```

Copy the iptables rule that you found on the Diego Cell that looks like the line above. Paste it in the story below.
It will be necessary to reference it soon.

```
# Put your iptables rule...
# HERE
```

ü§î **Decipher the iptables rule for the public_networks ASG**
When you run `iptables -S` the iptables rules are displayed in the format that they were created in. For example, if you prepended `iptables` to the line above and ran (DON'T! this is hypothetical) `iptables -A netout--772fbbd5-862a-4b3d-7 -m iprange ...` it would add that iptables rule. 

With that in mind, use `iptables --help` to define what the following flags mean and record it below...

```
-A                                 ...
-m                                 ...
--dst-range                        ...
-g                                 ...
-j                                 ...
```

1. What is the name of the chain that the above iptables rule is appended to? Let's call this CHAIN-NAME.
1. What conditions need to be met for a packet to match this rule?
1. If logging is enabled: If packets meet the above conditions, what chain of rules will they jump to and evaluate against next? Let's call this JUMP-TO-CHAIN-NAME.

1. Look at the rules only in the chains from the questions above.
 ```
iptables --list CHAIN-NAME
iptables --list JUMP-TO-CHAIN-NAME # <---- only if logging is enabled
 ```

Packets stop matching against iptables rules when they reach either the ACCEPT target(let the packet flow through!), the DROP target (stop that packet in its tracks!), or the REJECT target (nicely tell the sender that this destination is not available to them) targets.

ü§î **Read iptables rules to predict behavior**
1. Pretend there is a packet trying to hit the IP 23.96.32.148 via tcp. Where will it hit ACCEPT or DROP?
1. Pretend there is a packet trying to hit the IP 172.20.0.3 via tcp. Where will it hit ACCEPT or DROP?
1. ssh onto your app and try to curl 23.96.32.148. Did it succeed or fail? Did it match your expectations?
1. ssh onto your app and try to curl 172.20.0.3. Did it succeed or fail? Did it match your expectations?

### Expected Result
You should be able to find the iptables rules for the public_networks and be able to follow the flow to either ACCEPT or DROP.

Iptables are hard! Hopefully they have been demystified a little bit.
Spend some extra time looking at all the iptables rules on a Diego Cell. Research what you don't understand. Ask lots of questions.

## Resources
**iptables**
[iptables man page](http://ipset.netfilter.org/iptables.man.html)
[Julia Evans iptables basics](https://jvns.ca/blog/2017/06/07/iptables-basics/)
[Aidan's iptables ppt](https://docs.google.com/presentation/d/1qLkNu633yLHP5_S_OqOIIBETJpW3erk2QuGSVo71_oY/edit#slide=id.p)
[iptables primer](https://danielmiessler.com/study/iptables/)

**ASGs**
[Application Security Groups Documentation](https://docs.cloudfoundry.org/adminguide/app-sec-groups.html)
[Typical Application Security Groups](https://docs.cloudfoundry.org/adminguide/app-sec-groups.html#typical-groups)
[""Taking Security to the Next Level‚ÄîApplication Security Groups"" by Abby Kearns](https://blog.pivotal.io/pivotal-cloud-foundry/products/taking-security-to-the-next-level-application-security-groups)
[""Making sense of Cloud Foundry security group declarations"" by Sadique Ali](https://sdqali.in/blog/2015/05/21/making-sense-of-cloud-foundry-security-group-declarations/)

üôè _If this story needs to be updated: please, please, PLEASE submit a PR. Amelia will be eternally grateful. How? Go to [this repo](https://github.com/pivotal/cf-networking-program-onboarding). Search for the phrase you want to edit. Make the fix!_",asgs
Application Security Groups (ASGs) ‚áß,release,,asgs
Introducing Route Registrar,feature,"‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è
**WARNING: The Route Registrar stories are very new. ** You will probably find some typos. You will probably find some things that aren't as clear as they could be.
Please open a [PR or an issue](https://github.com/pivotal/cf-networking-program-onboarding) when you find these problems.
‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è

## What?

Cloud Foundry components (like CAPI, Diego, and Policy Server) are deployed into a private network. This means they can only be accessed within their network. But what if you want to make an endpoint to a CF component available outside of Cloud Foundry?

**Route Registrar** makes Cloud Foundry components available outside of Cloud Foundry. These routes get registered with the GoRouter, just like app routes.
Or, if you like analogies:  ```Route Registrar:CF Components::cf map-route:CF Apps```

In this Route Registrar series of stories you are going to create your own instance group to run a HTTP server. Then you are going to use route registrar to map a route to the server.

## Vocab üí¨

**Off-Platform** - Anything not in a Cloud Foundry deployment. This term is usually used when talking about where traffic originates. For example, traffic from Wendy (the end user) is off-platform traffic. Your local machine is off platform.

**On-Platform** - Anything that is within a Cloud Foundry deployment. This term is usually used when talking about where traffic originates. For example, when CAPI sends information to Diego, this is on-platform traffic.

**App Routes** - These are routes that resolve to a CF app.

**Component Routes** - These are routes that resolve to a bosh component. For example, uaa.beanie.c2c.cf-app.com is a component route that resolves to UAA.

## Notes
- This set of stories uses the instance group `my-http-server`, which you will create. It is handy to use this VM with nearly nothing on it so that there is much less traffic coming/going to it. However, all of this work _could_ be done on any VM.

üôè _If this story needs to be updated: please, please, PLEASE submit a PR. Amelia will be eternally grateful. How? Go to [this repo](https://github.com/pivotal/cf-networking-program-onboarding). Search for the phrase you want to edit. Make the fix!_",route-registrar
User Workflow - Life Without Route Registrar,feature,"## Assumptions
- You have an OSS CF deployed

## What?

In this story you are going to run your own HTTP server on a new bosh instance group _without_ creating a route via Route Registrar. This story will show why Route Registrar is needed.

## How?

üìù **Create your own instance group with no route registrar routes**

0. Deploy your own instance group by adding something like this to your bosh manifest

```
instance_groups:
- name: my-http-server
  azs:
  - z1
  instances: 2       # <------------ Make sure you have two instances for load balancing
  jobs:
  - name: route_registrar
    properties:
      route_registrar:
        routes: []   # <------------ No routes to start with
    release: routing
  networks:
  - name: default
  stemcell: default
  update:
    serial: true
  vm_type: minimal
```

üìù **Run an HTTP server on your new VMs**
0. Copy the http server code from [this gist](https://gist.github.com/ameowlia/2768de0c1d857a9981ed2df9809de6a9) onto your local machine.
0. Look at the file. It is a small go program that starts an HTTP server on port 9994 that responds to any request with a friendly hello and the mac address of the machine responding.
0.  Compile and copy this file onto the new instance group VMs.
 ```
 GOOS=linux go build go-server.go                                   # <----- compile the golang server
 bosh scp go-server my-http-server:/tmp/go-server                   # <----- copy the compiled server to both instances of my-http-server
 bosh ssh my-http-server -c ""sudo mv /tmp/go-server /bin/go-server"" # <----- move the compiled server to the /bin/ directory on both instances of my-http-server
 ```
0.  In one terminal, ssh onto `my-http-server/0`, become root, and run the server.
0.  In a second terminal, ssh onto `my-http-server/1`, become root, and run the server.

üìù **Try to hit the http sever from your local machine**

0.  In a third terminal from your local machine, run `bosh is` and record the IPs for both instances of my-http-server. Let's call these MY_HTTP_SERVER_0_IP and MY_HTTP_SERVER_1_IP.

0. Still in the third terminal, try to `curl MY_HTTP_SERVER_0_IP:9994` .

0. Try to `curl MY_HTTP_SERVER_1_IP:9994`.

‚ùìWhat happens? Why can't you reach these endpoints?

üìù **Try to hit the http sever from within the private CF network**

0. In the third terminal, bosh ssh onto any VM other than my-http-server.

0. Try to `curl MY_HTTP_SERVER_0_IP:9994`.

0. Try to `curl MY_HTTP_SERVER_1_IP:9994`.

‚ùìWhy can you reach these endpoints?

### Expected Results

MY_HTTP_SERVER_0_IP and MY_HTTP_SERVER_1_IP are both within CF's private network. This means that those IPs are only accessible from within the private network. You should be able to hit the HTTP server from any other VM in your CF deployment. You should not be able to hit the HTTP server from your local machine.

üôè _If this story needs to be updated: please, please, PLEASE submit a PR. Amelia will be eternally grateful. How? Go to [this repo](https://github.com/pivotal/cf-networking-program-onboarding). Search for the phrase you want to edit. Make the fix!_",route-registrar
User Workflow - Life With Route Registrar,feature,"## Assumptions
- You have a CF deployed
- You have done the other stories in this section
- You have two instances of my-http-server deployed from the previous story.
- There is an HTTP server on both instances of my-http-server from the previous story.

## Recorded values from previous stories
```
MY_HTTP_SERVER_0_IP=<value>
MY_HTTP_SERVER_1_IP=<value>
```
## What?

Let's get that HTTP server accessible from off-platform! In this story you are going to add a route to my-http-server with route registrar. You will learn how route registrar load balances requests.

## How?

üìù **Update the instance group to include route registrar routes**

1. Run `cf domains` to find out the SYSTEM_DOMAIN for your deployment
2. Update your bosh manifest to add routes via route registrar. Redeploy.

```
instance_groups:
-  name: my-http-server
  azs:
  - z1
  instances: 2
  jobs:
  - name: route_registrar
    properties:
      route_registrar:
        routes:
        - name: meow-route               # <<< Add this new stuff to routes
          port: 9994                     # <<<
          registration_interval: 10s     # <<<
          uris:                          # <<<
          - meow.SYSTEM_DOMAIN           # <<< Make sure to replace SYSTEM_DOMAIN. You can also replace meow if you want. But why would you?
    release: routing
  networks:
  - name: default
  stemcell: default
  update:
    serial: true
  vm_type: minimal
```

ü§î**Run the HTTP server on both instances of my-http-server**
1. Look back at the story `Life Without Route Registrar` if you need help with this.

ü§î**Hit the route**
 1. Curl the route you created (with no port) from your local terminal.

You should see something like...
```Hello from machine with mac address 42:01:0a:00:01:14```

‚ùìCurl the route a couple more times. Does the mac address change? Why or why not?

### Expected results
You should see the mac address load balance evenly between the two instances of my-http-server. If you are only seeing one mac address, you might not have both servers running successfully.

üôè _If this story needs to be updated: please, please, PLEASE submit a PR. Amelia will be eternally grateful. How? Go to [this repo](https://github.com/pivotal/cf-networking-program-onboarding). Search for the phrase you want to edit. Make the fix!_",route-registrar
Route Registrar - Find Those Routes!,feature,"## Assumptions
- You have a CF deployed
- You have done the other stories in this section
- You have my-http-server deployed with route registrar routes setup from the previous story

## What?

In this story you are going to follow how route registrar registers routes (say that 5 times fast).

In the HTTP Routes section you learned how the Route Emitter on the Diego Cell repeatedly sends route registration messages to NATS. Then GoRouter subscribes to those NATS messages and then populates its route table. The same thing happens with component routes. But instead of the Route Emitter emitting routes (teehehe), it's Route Registrar that is emitting routes repeatedly.

## How?

ü§î **Look at NATS**

0. Subscribe to the the NATS messages for your component route from the my-http-server VM.
 - You can find the NATS username, password, and host on the my-http-server VM at `/var/vcap/jobs/route_registrar/config/registrar_settings.json`
 - See the story `Route Propagation - Part 3 - Route Emitter and NATS` if you help.

 ‚ùìHow do the component route NATS messages compare to the app route NATS messages?

ü§î**Look at the routes table**
0. Bosh ssh onto the router VM.
0. Look at the GoRouter routes table and find your component route.
 - See the story `Route Propagation - Part 4 - GoRouter` if you need a reminder on how to this.

 ‚ùìHow does the component route compare to the app routes?

### Bonus Question

‚ùì‚ùì‚ùìSo if GoRouter routes off-platform users to other components, how do off-platform users route to GoRouter?!?!

### Expected Result
There are (almost) no differences between the app routes and the component routes. GoRouter does not know the difference between them and treats them the same.

üôè _If this story needs to be updated: please, please, PLEASE submit a PR. Amelia will be eternally grateful. How? Go to [this repo](https://github.com/pivotal/cf-networking-program-onboarding). Search for the phrase you want to edit. Make the fix!_",route-registrar
User Workflow - Instance Specific Routes,feature,"## Assumptions
- You have a CF deployed
- You have done the other stories in this section
- You have two instances of my-http-server deployed. (See story `Life Without Route Registrar` for help if needed).
- There is an HTTP server on both instances of my-http-server. (See story `Life Without Route Registrar` for help if needed).

## What?

In the `Life With Route Registrar` story you got the component route working and load balancing between two instances of my-http-server. But what if you want to be able to target a specific instance?

In this story you are going to create instance specific component routes.

## How

ü§î**Make and use instance specific routes**

0. Update the [prepend_instance_index property](https://github.com/cloudfoundry/routing-release/blob/develop/jobs/route_registrar/spec#L95-L96) in your bosh manifest to turn on instance specific routing.

0. Redeploy

0. Use the new routes!

0. Prove that you are hitting only one instance and that you can choose which instance you are hitting.

ü§î**Check the gorouter routing table**

0. Look at the gorouter routes table and find your instance component routes.

 ‚ùìHow do these routes differ from the route you saw in the `Life With Route Registrar` story?

üôè _If this story needs to be updated: please, please, PLEASE submit a PR. Amelia will be eternally grateful. How? Go to [this repo](https://github.com/pivotal/cf-networking-program-onboarding). Search for the phrase you want to edit. Make the fix!_",route-registrar
Route Registrar ‚áß,release,,route-registrar
Introducing Bosh DNS,feature,"‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è
**WARNING: The Bosh DNS stories are very new. ** You will probably find some typos. You will probably find some things that aren't as clear as they could be.
Please open a [PR or an issue](https://github.com/pivotal/cf-networking-program-onboarding) when you find these problems.
‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è

## Assumptions
- You have completed the Route Registrar stories

## What?

As you learned in the last section, Route Registrar is used to create routes that make CF components available to off-platform users. You _could_ use these routes for talking from one CF component to another, _but you should not_. Using Route Registrar in place of internal component routes (1) exposes CF components unnecessarily to the big bad internet and (2) adds extra hops through the load balancer and GoRouter, which cause latency.

So what do you do when one component wants to talk to another?

You use Bosh DNS!

In this Bosh DNS story series you are going to add a custom URL for an HTTP server and trace the DNS requests for Bosh DNS routes and non-Bosh DNS routes.

## Vocab

**DNS** - stands for **D**omain **N**ame **S**ystem. DNS translates domain names (urls) to IP addresses. You can do a DNS request in the terminal by using the command line tool `dig`. With dig you can learn that neopets.com resolves to 23.96.35.235.

**Bosh DNS** - provides native DNS Support for deployments (in our case, Cloud Foundry). It gives the bosh release creator (Rahcel, that's (probably) you!) an easy way to reference other VMs with load balancing. For example, you could set up Bosh DNS such that cc.cf.internal resolves to the IP for the VM where the Cloud Controller lives. This Bosh DNS server is typically deployed on every Bosh deployed machine in a deployment (that is, every Cloud Foundry VM) using a Bosh addon.

**Bosh DNS Routes** - routes available via Bosh DNS that route to Cloud Foundry components.

**Alias** - a custom Bosh DNS Route. For example you can make the alias meow.meow send traffic to the api VM. Fun!

**External URLs** - non-CF urls. Anything on the internet. Example: neopets.com.

### Notes
- This set of stories uses the instance group `my-http-server` that was created in the Route Registrar set of stories. It is handy to use this VM with nearly nothing on it so that there is much less traffic on it.
- The networking program does not maintain Bosh DNS. However, DNS resolution is an important part of the networking traffic flow, so it is important to understand how it works.

### Links
- [Bosh DNS Docs](https://bosh.io/docs/dns/)

üôè _If this story needs to be updated: please, please, PLEASE submit a PR. Amelia will be eternally grateful. How? Go to [this repo](https://github.com/pivotal/cf-networking-program-onboarding). Search for the phrase you want to edit. Make the fix!_",bosh-dns
Bosh DNS Reading,feature,"## What?

Read some docs!

1. Read the first two sections (""Architecture"" and ""Types of DNS addresses"") thoroughly
1. (At least) skim the rest

‚û°Ô∏è [Bosh DNS Docs](https://bosh.io/docs/dns/)

üôè _If this story needs to be updated: please, please, PLEASE submit a PR. Amelia will be eternally grateful. How? Go to [this repo](https://github.com/pivotal/cf-networking-program-onboarding). Search for the phrase you want to edit. Make the fix!_",bosh-dns
Bosh DNS -  DNS Requests for External URLs,feature,"## Assumptions
- You have a CF deployed
- You have done the other stories in this section
- You have 2 my-http-server instances deployed (see the story `User Workflow - Life Without Route Registrar` for setup)

## What?

In this story you are going to follow the DNS request for an external URL. Surprisingly (maybe) this will still involve Bosh DNS, even though the request is for an external URL.

## How?

üìù**See that your VM already has Bosh DNS**
By default Bosh DNS is on every VM in a OSS Cloud Foundry deployment.
1. Bosh ssh onto one of the my-http-server VMs and become root.
1.  Run `monit summary`. You should see a process called bosh-dns running.

üìù**Look at the DNS servers**

1. Bosh ssh onto one of the my-http-server VMs.
1. Look at the /etc/resolv.conf file. This file contains the IPs for the DNS servers used for all DNS lookups.

The file should look something like this.
```
$cat /etc/resolv.conf

# This file was automatically updated by bosh-dns
nameserver 169.254.0.2          <-------------- record this value as BOSH_DNS_IP

nameserver 169.254.169.254      <-------------- record this value as NON_BOSH_DNS_IP
search c.cf-container-networking-gcp.internal google.internal
```

üìù**Find Bosh DNS running**

So you have a value for BOSH_DNS_IP, but who do you _know_ this is the Bosh DNS IP?

1. Use netstat to see what IP the Bosh DNS process is bound to.

 ```
 $ netstat -tulpn

 Active Internet connections (only servers)
 Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name
 tcp        0      0 169.254.0.2:53          0.0.0.0:*               LISTEN      3227/bosh-dns
 tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      743/sshd
 tcp        0      0 127.0.0.1:53080         0.0.0.0:*               LISTEN      3227/bosh-dns
 tcp        0      0 127.0.0.1:2822          0.0.0.0:*               LISTEN      3300/monit
 tcp        0      0 127.0.0.1:2825          0.0.0.0:*               LISTEN      613/bosh-agent
 udp        0      0 169.254.0.2:53          0.0.0.0:*                           3227/bosh-dns
 ```

üìù**Do a non-Bosh DNS lookup**

1. Use dig to do a DNS request for any non-CF url.

 ```
 $ dig neopets.com

 ; <<>> DiG 9.10.3-P4-Ubuntu <<>> neopets.com
 ;; global options: +cmd
 ;; Got answer:
 ;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 35487
 ;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1

 ;; OPT PSEUDOSECTION:
 ; EDNS: version: 0, flags:; udp: 512
 ;; QUESTION SECTION:
 ;neopets.com.			IN	A

 ;; ANSWER SECTION:
 neopets.com.		3599	IN	A	23.96.35.235

 ;; Query time: 49 msec
 ;; SERVER: 169.254.0.2#53(169.254.0.2)
 ;; WHEN: Thu Oct 03 18:15:20 UTC 2019
 ;; MSG SIZE  rcvd: 67
 ```

1. Let's go through and try to understand this dig request.

| **snippet from dig response** |  **meaning** |
| -- | -- |
|`ANSWER: 1` |This means that the DNS request successfully found an IP for the url. If an IP was not found, it would be `ANSWER: 0`|
|`23.96.35.235` |This is the IP for the neopets.com. Try it in your browser! |
|`SERVER: 169.254.0.2#53(169.254.0.2)` |This means that the DNS server that handled this request is at IP 169.254.0.2 and port 53 (this is the standard port for DNS requests). |

Do you recognize that server IP? That's the BOSH_DNS_IP that you recorded earlier!

üìù**Look at logs**

1. Look at the bosh DNS logs. You should see something like...

 ```
$ tail -f /var/vcap/sys/log/bosh-dns/bosh_dns*

 [ForwardHandler] 2019/10/03 18:15:20
 INFO - handlers.ForwardHandler Request [1]
 [neopets.com.] 0 [recursor=169.254.169.254:53] 49064000ns
 ```
1. Do you recognize that recursor IP? That's the NON_BOSH_DNS_IP you recorded earlier!

‚ùìWhat is a recursor?

üìù**Tell dig what DNS server to use**

1. Try digging the external URL again, but this time force dig to use the BOSH_DNS_IP as the DNS server
‚ùìDoes this succeed? Why or why not?

1. Try digging the external URL again, but this time force dig to use the NON_BOSH_DNS_IP as the DNS server
‚ùìDoes this succeed? Why or why not?

### Expected Outcomes
Bosh DNS only knows information about Bosh DNS routes. For any other URL (neopets, for example) asks a different DNS server. Both the Bosh DNS server and the non-Bosh DNS server can (with recursion) resolve the external URL.

### Helpful Commands

**Do a DNS lookup**
```
dig URL [@SERVER_IP]

# for example
dig neopets.com @169.254.4.4
```

üôè _If this story needs to be updated: please, please, PLEASE submit a PR. Amelia will be eternally grateful. How? Go to [this repo](https://github.com/pivotal/cf-networking-program-onboarding). Search for the phrase you want to edit. Make the fix!_",bosh-dns
Add a Custom Bosh DNS Alias,feature,"## Assumptions
- You have a CF deployed
- You have done the other stories in this section
- You have 2 my-http-server instances deployed (see the story `User Workflow - Life Without Route Registrar` for setup)

## Recorded values from previous stories
```
BOSH_DNS_IP=<value>
NON_BOSH_DNS_IP=<value>
```

## What?
In this story you are going to add your own fun alias for your go HTTP server.

## How?

üìù**Add your own alias**

1. Update your manifest to include a Bosh DNS alias. This alias could be added for any job on the instance group.
 ```
 - name: my-http-server
# ...
   jobs:
   - name: route_registrar
     provides:                             # < ------------ Add this block to add a Bosh DNS alias
       my_custom_link:                     # < ------------
         aliases:                          # < ------------
         - domain: ""meow.meow""             # < ------------ Make the domain anything you want :D
           health_filter: ""healthy""        # < ------------ Record the domain you choose as HTTP_SERVER_ALIAS
     custom_provider_definitions:          # < ------------
     - name: my_custom_link                # < ------------
       type: my_custom_link_type           # < ------------
 ```

1. Redeploy

1. Make sure the go server is running on both of your my-http-server VMs. See the story ` Life Without Route Registrar` for help with this step.

1. Bosh ssh onto any machine _except_ the my-http-server VM.

1. Wait a couple minutes...

1. Try to access your new URL! Success!

 ```
 $ curl HTTP_SERVER_ALIAS:9994

 Hello from machine with mac address 42:01:0a:00:01:16
 ```

1. Try to access your new URL from your local machine.
 ```
 $ curl HTTP_SERVER_ALIAS:9994

 curl: (6) Could not resolve host: meow.meow
 ```

## Expected Results

Your new alias should only be accessible within Cloud Foundry and not from your local machine.

üôè _If this story needs to be updated: please, please, PLEASE submit a PR. Amelia will be eternally grateful. How? Go to [this repo](https://github.com/pivotal/cf-networking-program-onboarding). Search for the phrase you want to edit. Make the fix!_",bosh-dns
Bosh DNS Records Table,feature,"## Assumptions
- You have a CF deployed
- You have done the other stories in this section
- You have my-http-server deployed with an alias setup from the previous story

## Recorded values from previous stories
```
BOSH_DNS_IP=<value>
NON_BOSH_DNS_IP=<value>
HTTP_SERVER_ALIAS=<value>
```

## What?
So how does Bosh DNS work? How does it figure out what IP to send traffic to?

## How?

üìù**Find your alias in the Bosh DNS records table**

1. Bosh ssh onto any VM in your CF deployment.
1. Look at the Bosh DNS records table. (You might need to install jq)
 ```
 cat /var/vcap/instance/dns/records.json | jq .
 ```
1. Find the data about HTTP_SERVER_ALIAS.

‚ùìWhat data is present?
‚ùìIf you delete this file does Bosh DNS still work on this machine?
‚ùìWhat is updating this file? (hint: read the [Bosh DNS Docs](https://bosh.io/docs/dns/))

### Links
- [Bosh DNS Docs](https://bosh.io/docs/dns/)

üôè _If this story needs to be updated: please, please, PLEASE submit a PR. Amelia will be eternally grateful. How? Go to [this repo](https://github.com/pivotal/cf-networking-program-onboarding). Search for the phrase you want to edit. Make the fix!_",bosh-dns
Bosh DNS - DNS Requests for Bosh DNS Aliases,feature,"## Assumptions
- You have a CF deployed
- You have done the other stories in this section
- You have my-http-server deployed with an alias setup from the previous story

## Recorded values from previous stories
```
BOSH_DNS_IP=<value>
NON_BOSH_DNS_IP=<value>
HTTP_SERVER_ALIAS=<value>
```

## What?
In this story you are going to look at what happens under the hood when you do a DNS request for HTTP_SERVER_ALIAS.

## How?

üìù**Do a DNS lookup for your alias**
1. Bosh ssh onto any Cloud Foundry VM
1. Use dig to do a DNS request for your alias.

 ```
 $ dig HTTP_SERVER_ALIAS

 ; <<>> DiG 9.10.3-P4-Ubuntu <<>> meow.meow
 ;; global options: +cmd
 ;; Got answer:
 ;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 28967
 ;; flags: qr aa rd ra; QUERY: 1, ANSWER: 2, AUTHORITY: 0, ADDITIONAL: 0

 ;; QUESTION SECTION:
 ;meow.meow.			IN	A

 ;; ANSWER SECTION:
 meow.meow.		0	IN	A	10.0.1.23   # <------------ This should match the IP of one of the my-http-server VMs
 meow.meow.		0	IN	A	10.0.1.22   # <------------ This should match the IP of the other my-http-server VM

 ;; Query time: 2 msec
 ;; SERVER: 169.254.0.2#53(169.254.0.2)        # <------------ This should match the BOSH_DNS_IP
 ;; WHEN: Thu Oct 03 20:45:06 UTC 2019
 ;; MSG SIZE  rcvd: 83
 ```

üìù**Look at logs**

1. Look at the bosh-dns logs on the machine you did the dig on in the steps above

 ```
 $ tail -f /var/vcap/sys/log/bosh-dns/bosh_dns*

 [RequestLoggerHandler] 2019/10/03 20:49:43
 INFO - handlers.DiscoveryHandler Request [1]
 [amelia.meow.] 0 160000ns                     # <------------ Note, there is no recursor
 ```

‚ùì Remember how with neopets.com there was a recursor in the logs? Based on what you know about recursors, why do you think there is no recursor listed in this log line?

üìù**Tell dig what DNS server to use**

1. Try digging your alias again, but this time force dig to use the BOSH_DNS_IP as the DNS server
‚ùìDoes this succeed? Why or why not?

1. Try digging your alias again, but this time force dig to use the NON_BOSH_DNS_IP as the DNS server
‚ùìDoes this succeed? Why or why not?

### Expected Results
The Bosh DNS server knows how to recurse to the non-Bosh DNS server. However, the non-Bosh DNS server does not recurse to the Bosh DNS server. Because of this, the non-Bosh DNS server will not be able to resolve HTTP_SERVER_ALIAS.

### Helpful Commands

**Do a DNS lookup**
```
dig URL [@SERVER_IP]

# for example
dig neopets.com
# OR
dig neopets.com @169.254.4.4
```

üôè _If this story needs to be updated: please, please, PLEASE submit a PR. Amelia will be eternally grateful. How? Go to [this repo](https://github.com/pivotal/cf-networking-program-onboarding). Search for the phrase you want to edit. Make the fix!_",bosh-dns
Can CF Apps Use Bosh DNS?,feature,"## Assumptions
- You have a CF deployed
- You have done the other stories in this section
- You have my-http-server deployed with an alias setup from the previous story

## Recorded values from previous stories
```
BOSH_DNS_IP=<value>
NON_BOSH_DNS_IP=<value>
HTTP_SERVER_ALIAS=<value>
```

## What?
In the previous stories you learned how to set up and use a Bosh DNS alias to curl the golang http server from other Bosh VM. But what about CF apps? Can apps use Bosh DNS aliases?

## How?

ü§î**Try your Bosh DNS alias from an app**

1. Push any app
1. Cf ssh onto that app
1. Curl HTTP_SERVER_ALIAS:9994

‚ùìDoes it work? Why or why not? Are iptables involved? (hint: yes)

ü§î**Make your Bosh DNS alias available from an app**

1. Update your ASGs (application security groups) to make the alias available to your app.

## Expected Result

Most likely, the default security groups for your CF deployment do not give your apps access to any private IP ranges. If you update the ASGs to allow apps access to private IPs (specifically, the IPs for the my-http-server VMs) your app should be able to use the alias.

If it is not working:
- make sure you restarted your app after applying the security group
- wait a couple minutes. The DNS records seem to take a little bit to propagate throughout the CF deployment.

üôè _If this story needs to be updated: please, please, PLEASE submit a PR. Amelia will be eternally grateful. How? Go to [this repo](https://github.com/pivotal/cf-networking-program-onboarding). Search for the phrase you want to edit. Make the fix!_",bosh-dns
Bosh DNS ‚áß,release,,bosh-dns
OSI Networking Model Primer,feature,"## Assumptions
- None

## What

The stories have been throwing around terms like IP, HTTP, DNS, DNAT without talking about the broader networking context around these terms.

In this next track of work you will start looking at TCP as well. There are some crucial differences between HTTP Routes and TCP Routes, that will make more sense if you understand what layer of networking those different protocols are on.

In this story you are going to learn about the OSI model (Open Systems Interconnection model). In the OSI model, there are 7 networking layers and each one is built on top of the one below it.

![OSI model](https://storage.googleapis.com/cf-networking-onboarding-images/osi-layers.png)

## How

üé• Watch Gabe's talk [""Networking 101 for Software Engineers""](https://www.youtube.com/watch?v=6_FHs_g1yw4)

Watch from start to 35:26.

The whole talk is great. If you have the time, watch the whole thing.

## Questions
‚ùìWhat layer is TCP at?
‚ùìWhat layer is IP at?
‚ùìWhat layer is HTTP at?

üôè _If this story needs to be updated: please, please, PLEASE submit a PR. Amelia will be eternally grateful. How? Go to [this repo](https://github.com/pivotal/cf-networking-program-onboarding). Search for the phrase you want to edit. Make the fix!_","tcp-routes,questions"
User Workflow: TCP Routes,feature,"## Assumptions
- You have a CF deployed
- The CF was deployed with the help of `bbl`
- You have one TCP Router deployed. (Check by running `bosh vms` and looking for a VM called tcp-router). If you have more than one that's okay, but the steps written below assume that there is only one.

## What
GoRouter only handles incoming HTTP traffic.  All of the routes that we have been talking about so far are *HTTP* routes (though we often drop the HTTP in conversation and just call them routes). If you want to send og TCP traffic, then you are going to need to set up a TCP route. 

There is a parallel system for TCP routes similar to HTTP routes:
- An HTTP client connects to an HTTP route on an HTTP domain, though an HTTP load balancer, which sends traffic to HTTP Routers (GoRouters).
- TCP client connects to a TCP route on a TCP domain, through a TCP load balancer, which sends traffic to TCP Routers.

```
                                                   +-----------+
 +-----------+         +------------------+        |HTTP Router|        +------+
 |HTTP Client| ----->  |HTTP Load Balancer| -----> |(GoRouter) | -----> |      |
 +-----------+         +------------------+        +-----------+        |      |
                                                                        | App  |
 +-----------+         +------------------+        +-----------+        |      |
 |TCP Client | ----->  |TCP Load Balancer | -----> |TCP Router | -----> |      |
 +-----------+         +------------------+        +-----------+        +------+

```

Let's create a TCP Route and send traffic to it!

## How

üìù **Prep in Google Cloud Console**
1. Make sure that you have DNS set up properly for the TCP Router.
    In Google Cloud Console, go to the Zone Details for your env (Network Services --> Cloud DNS --> <your-env>-zone)
1. You should find a domain that starts with `tcp`, let's call this TCP_DOMAIN. This domain should have an IP next to it, let's call this TCP_LOAD_BALANCER_IP.
    ![example TCP domain DNS on GCP](https://storage.googleapis.com/cf-networking-onboarding-images/example-tcp-domain-dns.png)

1. In Google Cloud Console, find the Load Balancer with the ip TCP_LOAD_BALANCER_IP. (Network Services --> Load balancing)
    Here you will be able to see all of the VMs that the load balancer ...balances load between. In the example below, and most likely in your case, there is only one TCP Router deployed, so there will only be one VM listed.

    ![example TCP load balancer on GCP](https://storage.googleapis.com/cf-networking-onboarding-images/example-tcp-load-balancer.png)

1. Click the VM instance that the TCP load balancer sends traffic to. Find the VM's internal IP. Let's call this TCP_ROUTER_IP.
   ![example TCP router vm on GCP](https://storage.googleapis.com/cf-networking-onboarding-images/example-tcp-router-details.png)
1. In the terminal, check that the TCP_ROUTER_IP matches the IP that bosh reports for the TCP Router. It comes full circle!

üìù **Push a TCP server app**
1. Push [this tcp listener app](https://github.com/cloudfoundry/cf-acceptance-tests/tree/master/assets/tcp-listener) with no HTTP route.
 This app is listening for TCP traffic on port 8080 and it logs all of the messages sent to it.
 ```
 cf push tcp-app --no-route
 ```

üìù **Create a TCP Route**
1. See that you have a default-tcp router group. Router Groups are used to reserve ports for tcp routes.
 ```
 cf router-groups
 ```
1. Create a shared TCP domain
 ```
cf create-shared-domain TCP_DOMAIN --router-group default-tcp
 ```
1. See that `cf map-route --help` has different usage instructions for TCP routes and HTTP routes.
1. Create a route with the TCP domain and map it to tcp-app, let's call this TCP_ROUTE:TCP_PORT.
 ```
 cf map-route tcp-app TCP_DOMAIN --random-port
 ```

### Expected Result

üìù **test with curl**
Curl sends traffic via HTTP(S), but because HTTP is built on top of TCP, we can still use curl to test out TCP route.
1. In one terminal, run `cf logs tcp-app`
1. In another terminal `curl TCP_ROUTE:TCP_PORT`
1. See the HTTP headers show up in your logs

ü§î **test with netcat**
Netcat is a helpful utility for reading and writing traffic over TCP or UDP. You will use netcat to send tcp traffic.
1. In one terminal, run `cf logs tcp-app`
1. In another terminal, run a docker container and get some helpful tools
    ```
docker run --privileged -it ubuntu bin/bash
apt-get update -y
apt-get install netcat -y
    ```
1. Use `nc -h` to look at the help text and figure out how to connect to TCP_ROUTE:TCP_PORT.
1. If you successfully open a connection, it will hold it open so you can type anything. Mash some keys and press enter.
1. See your key mashes in the app logs. You sent that via TCP!

Don't delete your TCP app/route/domain yet! You'll need them in the next stories.

## Extra Credit
‚ùìWhat happens if you try to send TCP traffic to an HTTP route? Why can you send HTTP traffic (kind of) over TCP, but not the other way around?

## Resources

[Basic Golang TCP Server](https://coderwall.com/p/wohavg/creating-a-simple-tcp-server-in-go)
[CF Docs - configure TCP domain](https://docs.cloudfoundry.org/adminguide/enabling-tcp-routing.html#-configure-cf-with-your-tcp-domain)
[CF Docs - HTTP vs TCP routes](https://docs.cloudfoundry.org/devguide/deploy-apps/routes-domains.html#-http-vs.-tcp-routes)
[CF Docs - create TCP routes](https://docs.cloudfoundry.org/devguide/deploy-apps/routes-domains.html#-create-a-tcp-route-with-a-port)
[Sending tcp traffic via netcat](https://askubuntu.com/questions/443227/sending-a-simple-tcp-message-using-netcat)
[netcat fun! by julia evans](https://jvns.ca/blog/2013/10/01/day-2-netcat-fun/)
[Did you brew install nc on your mac and it broke bosh? yup.](https://github.com/cloudfoundry/bosh-cli/pull/403)

üôè _If this story needs to be updated: please, please, PLEASE submit a PR. Amelia will be eternally grateful. How? Go to [this repo](https://github.com/pivotal/cf-networking-program-onboarding). Search for the phrase you want to edit. Make the fix!_","tcp-routes,user-workflow,questions"
Dig-ing TCP and HTTP Routes,feature,"## Assumptions
- You have a CF deployed
- The CF was deployed with the help of `bbl`
- You have a TCP server deployed named tcp-app
- You have a TCP route mapped to tcp-app called TCP_ROUTE
- You have a 2 [proxy](https://github.com/cloudfoundry/cf-networking-release/tree/develop/src/example-apps/proxy) apps pushed, that are named appA and appB
- You have a HTTP route mapped to appA called APP_A_ROUTE and one mapped to appB called APP_B_ROUTE

## What
`dig` is one of many network utilities that can be very helpful for debugging. Dig does a DNS lookup for a URL.

Let's play around with dig, TCP Routes, and HTTP Routes.

## How

üìù **Dig with a good URL**
1. Run `dig neopets.com`
    If you see `ANSWER 1` (which you should) that it was able to resolve the route. `ANSWER 0` means it was unable to resolve the route.
    In the `ANSWER SECTION` you should see an IP. (Likely, 23.96.35.235)
1. Put the IP that neopets.com resolved to in a browser. Is it neopets?

üìù **Dig with a bogus URL**
1. Resolve a bogus URL so you get ANSWER 0.

üìù **Dig with CF HTTP routes**
1. Use dig to resolve APP_A_ROUTE. Let's call this APP_A_IP
1. Curl that IP. What happens?

1. Use dig to resolve APP_B_ROUTE. Let's call this APP_B_IP
1. Curl that IP. What happens?
‚ùìWhy are APP_A_IP and APP_B_IP the same?
‚ùìWhy doesn't the IP resolve to either of the apps?

üìù **Dig with CF TCP routes**
1. Use dig to resolve the TCP Route. Let's call this TCP_APP_IP
1. Curl that IP. What happens?
‚ùìIs TCP_APP_IP the same as APP_A_IP?
‚ùìWhy or why not?
‚ùìHow does traffic get to the apps if the IPs don't work?

ü§î **Sleuthing in your IAAS**
1. In your IAAS GUI, find what infrastructure that these IPs map to.

### Expected Results
All CF HTTP Routes resolve to the same IP. All CF TCP Routes resolve to the same IP. You should find the load balancers that map to these IPs.

## Extra Credit
‚ùìWhy does `dig neopets.com` work, but `dig http://neopets.com` does not work?

## Resources
[understanding the dig command](https://mediatemple.net/community/products/dv/204644130/understanding-the-dig-command)

üôè _If this story needs to be updated: please, please, PLEASE submit a PR. Amelia will be eternally grateful. How? Go to [this repo](https://github.com/pivotal/cf-networking-program-onboarding). Search for the phrase you want to edit. Make the fix!_","tcp-routes,questions"
"Route Ports, Backend Ports, App Ports Oh My!",feature,"## What
Earlier in this track of TCP work you created a TCP route. This TCP route needed a port.  This is called a route port. There are 3 different types of ports in the Cloud Foundry ecosystem. They can be extremely confusing, so it is nice if there is clear vocabulary so you can easily describe which port you are talking about. 

The three types of ports are:

**Route Port** - this is the port that a client makes a connection to. For HTTP routes, this is always 80 (for http) or 443 (for https). For TCP routes, this port is configured and unique.

**Backend Port** - this is the high number port on the Diego Cell that the GoRouter or TCP Router proxies traffic to. This port is unique per app on each Diego Cell.

**App Port** - this is the port where the app is listening inside of the container. In CF this defaults to 8080.

Let's look at a diagram of these ports.

![ports for TCP traffic](https://storage.googleapis.com/cf-networking-onboarding-images/tcp-trafficflow-ports.png)

![ports for HTTP traffic](https://storage.googleapis.com/cf-networking-onboarding-images/http-traffic-flow-ports.png)

## Questions
‚ùìLook at the help text for mapping a route (`cf map-route --help`). What are the different flags allowed for HTTP routes vs TCP routes?
‚ùìHow do these different flags align with what you learned in this story?

## Resources
[configuring app ports in CF](https://docs.cloudfoundry.org/devguide/custom-ports.html)

üôè _If this story needs to be updated: please, please, PLEASE submit a PR. Amelia will be eternally grateful. How? Go to [this repo](https://github.com/pivotal/cf-networking-program-onboarding). Search for the phrase you want to edit. Make the fix!_","tcp-routes,questions"
TCP vs HTTP Routes,feature,"## What

Earlier in this track, you learned that all CF HTTP Routes resolve to the IP of the HTTP load balancer and that all TCP Routes resolve to the IP of the TCP Load balancer.

But if _all_ routes resolve to the IP of a load balancer, then how does traffic actually get sent to an application????

Well, it depends if the route is HTTP or TCP.

One major difference between the HTTP protocol and the TCP protocol, is that HTTP packets contain more headers. These headers can carry all sorts of information, including what URL the request is being made to. (The client can even set arbitrary headers themselves!) GoRouter is able to look at this headers, see the requested URL, and route appropriately based on the information in the Routes Table. Because of this, all HTTP routes can have identical route ports (80 or 443).

![gorouter routing](https://storage.googleapis.com/cf-networking-onboarding-images/gorouter-traffic-routing.png)

TCP is barebones. TCP packets have very limited headers that only include the source and destination ports of the packets. Because of this, the TCP Router has _no_ knowledge of the URL. So the TCP Router needs something else to differentiate between apps. It can't be the destination IP because all TCP routes have the same destination IP. The only thing left, is the destination port. Because of this, all TCP routes must have unique route ports.

![tcp router routing](https://storage.googleapis.com/cf-networking-onboarding-images/tcp-traffic-routing.png)

## How
üìù**Inspect HTTP headers**
1. Curl the networking api and look at the request headers
 ```
cf curl /networking/v1/external/policies -v
 ```
 You should get a response that looks like this:
 ```
REQUEST: [2019-04-24T11:01:49-07:00]
GET /networking/v1/external/policies <---- this is the header that contains the URL path
HTTP/1.1
Host: api.beanie.c2c.cf-app.com      <---- this is the header that contains the URL base
Accept: application/json
Authorization: [PRIVATE DATA HIDDEN]
Content-Type: application/json
User-Agent: go-cli 6.43.0+815ea2f3d.2019-02-20 / darwin
 ```

## Question
‚ùìWhat would happen if two TCP routes had the same route port?

## Resources
[tcp header format](https://www.freesoft.org/CIE/Course/Section4/8.htm)
[http headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers)

üôè _If this story needs to be updated: please, please, PLEASE submit a PR. Amelia will be eternally grateful. How? Go to [this repo](https://github.com/pivotal/cf-networking-program-onboarding). Search for the phrase you want to edit. Make the fix!_","tcp-routes,questions"
TCP Routes Table,feature,"## Assumptions
- You have a CF deployed
- The CF was deployed with the help of `bbl`
- You have a TCP server deployed named tcp-app
- You have a TCP route mapped to tcp-app called TCP_ROUTE

## What

The TCP traffic flow is nearly identical to the HTTP traffic flow. The big difference is that instead of an HTTP load balancer there is a TCP load balancer and instead of GoRouter there is a TCP Router.

Go back to the story _Route Propagation - Part 0.2 - HTTP Traffic Overview_ to review this flow.

In the story _Route Propagation - Part 4 - GoRouter_  you learned how to look at the route table for the GoRouter. In this story you are going to look at the analogous route table for the TCP Router.

## How

üìù **Try to list tcp routes**
1. List tcp routes via the routing api.
 ```
cf curl /routing/v1/tcp_routes
 ```
 Most likely you will get the error message:
 ```
{""name"":""UnauthorizedError"",""message"":""Token is expired""}
 ```

ü§î **Get correct permissions**
Based on the [routing api docs](https://github.com/cloudfoundry/routing-api/blob/master/docs/api_docs.md#list-tcp-routes), you need to have a client with routing.routes.read permissions.

There is probably already a client deployed with the correct permissions. Find out the name and password for this user from the bosh manifest.

1. Download your manifest
 ```
bosh manifest > /tmp/my-env.yml
 ```

1. Search for `routing.routes.read`

 You should find uaa client properties that look like this:

 ```
 routing_api_client:
            authorities: routing.routes.write,routing.routes.read,routing.router_groups.read
            authorized-grant-types: client_credentials
            secret: ((uaa_clients_routing_api_client_secret))
 ```
The name of the client is: routing_api_client. The password is in credhub under the key uaa_clients_routing_api_client_secret.

1. Use the credhub CLI to get the password.

üìù **Use uaac to get the oath token**

1. Run `uaac` to see if you have the uaa CLI installed.

1. If you don't have it installed, install it.
 ```
gem install cf-uaac
 ```

1. Target your uaa. (To determine this url you can run `cf api` and replace api with uaa.)
 ```
uaac target uaa.<YOUR-ENV>.com
 ```

1. Get the client information for the routing_api_client. It will prompt you for a password.
 ```
uaac token client get routing_api_client
 ```

1. Get the bearer token
 ```
uaac context
 ```
 You will see something like this (this one is truncated):
 ```
client_id: routing_api_client
access_token: eyJhbGciOiJ <------- This is the bearer token that you will need. Yours will be longer.
token_type: bearer
expires_in: 43199
scope: routing.router_groups.read routing.routes.write routing.routes.read
 ```

üìù **Get tcp routes**
1. This time when you curl, pass in the bearer token as a header.
 ```
cf curl /routing/v1/tcp_routes -H ""Authorization: bearer BEARER_TOKEN"" | jq .
 ```

### Expected Outcome

You should see one TCP route that looks like the one below (this one is edited for brevity):
```
{
    ""router_group_guid"": ""e47c747a-d655-4ea8-5f1a-b59f21ad7852"",
    ""backend_port"": 61004,         <--------- This is the backend port
    ""backend_ip"": ""10.0.1.12"",     <--------- This is the Diego Cell IP
    ""port"": 1025,                  <--------- This is the route port
    ""isolation_segment"": """"
}
```
## Questions
‚ùìGo back to the story _Route Propagation - Part 4 - GoRouter_  and look at the example HTTP route table entry. What differences do you see between the TCP routes and the HTTP routes?
‚ùìHow does this difference match with what you understand about TCP and HTTP?

## Resources
[routing api docs](https://github.com/cloudfoundry/routing-api/blob/master/docs/api_docs.md#list-tcp-routes)

üôè _If this story needs to be updated: please, please, PLEASE submit a PR. Amelia will be eternally grateful. How? Go to [this repo](https://github.com/pivotal/cf-networking-program-onboarding). Search for the phrase you want to edit. Make the fix!_","tcp-routes,questions"
Why are my TCP routes broken? - Part 0 - Setup,feature,"## Assumptions
- You have a CF deployed
- The CF was deployed with the help of `bbl`
- You have completed the ""iptables-primer"" track
- You have a TCP server deployed named tcp-app
- You have a TCP route mapped to tcp-app called TCP_ROUTE:TCP_PORT

## What
When writing these stories, I happened to have a particular deploy setup that caused TCP routes to break and took me awhile to debug. Hopefully this bug is fixed by the time you are reading this, so for this story you're going to have to deploy older code to get the broken state.

## How
ü§î**Setup**
1. If your environment is running istio-release 1.2.0 you are good to go. Skip to the next section.
1. Save your current manifest so you can get back to it easily after this story.
 ```
bosh manifest > /tmp/bosh.yml
 ```
1. Deploy with istio-release 1.2.0 and use the [recommended opsfiles](https://github.com/cloudfoundry/istio-release/tree/v1.2.0/deploy/cf-deployment-operations).
   Make sure that the `experimental_enable_ingress_proxy_redirect` property on the `garden-cni` job is set to true

üìù **See it break**
1. See that `curl TCP_ROUTE:PORT` no longer works

ü§î **Now fix it!**
At this point it is a choose your own adventure.
There are 3 stories that you could follow, each with different levels of help text.

Option 1: Solo adventure. No map. No compass. - This option has no hand holding. You are left on your own to find and fix the bug.

Option 2: Some hints. You have a compass, but no map. - This option provides thoughtful questions and hints to probe you in the correct direction.

Option 3: Step by step directions. You have a compass and a map. - This option provides instructions on how to debug each component to figure out which component is broken.

I suggest starting with option 1 or 2 and then looking ahead to options 2 and 3 as you need help.

All of the previous stories that taught you about iptables, tcpdump, routing tables, etc should set you up how to debug CF. However, one thing that will become helpful, but that hasn't been covered previously is [how to get into a container's networking namespace as root](https://cloudfoundry.slack.com/archives/GFXGACQUB/p1554758849206400).

This your chance to put your debugging skills to the test. You can do it.
Ready. Set. Debug!

## Resources
[How to get into a container's networking namespace as root](https://cloudfoundry.slack.com/archives/GFXGACQUB/p1554758849206400)

üôè _If this story needs to be updated: please, please, PLEASE submit a PR. Amelia will be eternally grateful. How? Go to [this repo](https://github.com/pivotal/cf-networking-program-onboarding). Search for the phrase you want to edit. Make the fix!_",tcp-routes
Why are my TCP routes broken? - Option 1 - hard,feature,"## Assumptions
- You have a CF deployed
- The CF was deployed with the help of `bbl`
- You have a TCP server deployed named tcp-app
- You have a TCP route mapped to tcp-app called TCP_ROUTE:TCP_PORT

## What
Find the bug that is breaking TCP routes and fix it.
This is option 1. This option has no hand holding. You are left on your own to find and fix the bug.

## How
üìù **See it break**
1. See that `curl TCP_ROUTE:PORT` no longer works

ü§î **Now fix it!**
1. Debug

### Expected Result
Find the bug. Remove the offender and get this TCP route working!
Don't forget to redeploy to your old state afterwards.

## Resources
[How to get into a container's networking namespace as root](https://cloudfoundry.slack.com/archives/GFXGACQUB/p1554758849206400)

üôè _If this story needs to be updated: please, please, PLEASE submit a PR. Amelia will be eternally grateful. How? Go to [this repo](https://github.com/pivotal/cf-networking-program-onboarding). Search for the phrase you want to edit. Make the fix!_",tcp-routes
Why are my TCP routes broken? - Option 2 - medium,feature,"## Assumptions
- You have a CF deployed
- The CF was deployed with the help of `bbl`
- You have a TCP server deployed named tcp-app
- You have a TCP route mapped to tcp-app called TCP_ROUTE:TCP_PORT

## What
Find the bug that is breaking TCP routes and fix it.
This is option 2. This option provides thoughtful questions and hints to probe you in the correct direction.

## How
üìù **See it break**
1. See that `curl TCP_ROUTE:PORT` no longer works

ü§î **Now fix it! With hints!**
1. Draw out the data flow for TCP routes include: the client, the load balancer, the TCP router, the Diego Cell, and the app container.
 Any step in that process could be broken.

1. Start at the beginning of the flow and test if the traffic is successfully making it to the next hop.

1. Follow the helpful questions to systematically debug the system.

## Hints
üîé **helpful questions**
‚ùìIs the URL being resolved to the correct load balancer IP?
‚ùìIs the traffic making it to the TCP router?
‚ùìDoes the TCP Router have information about the route in its route table?
‚ùìIs the TCP Router information correct?
‚ùìIs the traffic making it to the Diego Cell?
‚ùìAre the DNAT rules on the Diego Cell correct?
‚ùìIs the traffic making it to the app container?
‚ùìIs the traffic making it to the app process?

üîé **helpful tools**
- Use dig for DNS resolution. It turns a URL into an IP. See story _Dig-ing TCP and HTTP Routes_ for help.
- Use iptables to see if traffic is being directed somewhere (un)expected. See story _Route Propagation - Part 5 - DNAT Rules_ for help.
- Use tcpdump to see if traffic is making it to a container or vm. See story _Watch your c2c packets with tcpdump_ for help.
- Always look at logs
- See the resources section for how to get in the container's network namespace as root. So you can run all these helpful tool inside of the app container too.

### Expected Result
Find the bug. Remove the offender and get this TCP route working!
Don't forget to redeploy to your old state afterwards.

## Resources
[How to get into a container's networking namespace as root](https://cloudfoundry.slack.com/archives/GFXGACQUB/p1554758849206400)

üôè _If this story needs to be updated: please, please, PLEASE submit a PR. Amelia will be eternally grateful. How? Go to [this repo](https://github.com/pivotal/cf-networking-program-onboarding). Search for the phrase you want to edit. Make the fix!_","tcp-routes,questions"
Why are my TCP routes broken? - Option 3 - easy...er,feature,"## Assumptions
- You have a CF deployed
- The CF was deployed with the help of `bbl`
- You have a TCP server deployed named tcp-app
- You have a TCP route mapped to tcp-app called TCP_ROUTE:TCP_PORT

## What
Find the bug that is breaking TCP routes and fix it.
This is option 3: Step by step directions. You have a compass and a map. - This option provides instructions on how to debug each component to figure out which component is broken.

## How
üìù **See it break**
1. See that `curl TCP_ROUTE:TCP_PORT` no longer works

ü§î **Now fix it! With extra hints!**
1. Here is a diagram of the traffic flow for _working_ TCP routes.
 ![tcp route traffic flow](https://storage.googleapis.com/cf-networking-onboarding-images/tcp-trafficflow-ports.png)

 Any step in that process could be broken. Start at the beginning of the flow and test if the traffic is successfully making it to the next hop.

‚ùìIs the URL being resolved to the correct load balancer IP?
1. Use dig with the tcp route to determine if DNS is resolving the route correctly. The IP should match the TCP Load Balancer. Look back at the story _Dig-ing TCP and HTTP Routes_ if you forget how.
 If the IP matches the load balancer, then you know the request is being sent to the correct place. Check the next hop.

‚ùìIs the traffic making it to the TCP router?
1. Ssh onto the TCP router and become root.
1. Look at all network packets where the destination port is the TCP_PORT using tcpdump.
 ```
tcpdump 'port TCP_PORT'
 ```
1. Run  `curl TCP_ROUTE:TCP_PORT` while tcpdump is watching.
If tcpdump is seeing packets, that indicates that the load balancer is correctly proxying traffic to the TCP Router. It also means that the traffic is making it to the TCP Router.

‚ùìDoes the TCP Router have information about the route in the its route table?
1. Follow the steps in the story _TCP Routes Tables_ and see if there is an entry for TCP_PORT. If there is, then you know know that the router is being configured. Note down the Diego Cell IP and backend port (BACKEND_PORT).

‚ùìDoes the TCP Router's route table entry match app's backend information?
The TCP Router is proxying traffic for TCP_PORT to the Diego Cell IP and BACKEND_PORT, but are the variables correct?
1. CF ssh onto tcp_app and look at the environment variables. Do they match? If so, then you know that the TCP Router is proxying traffic to the correct location.

‚ùìIs the traffic making it to the Diego Cell?
The TCP Router is trying to  proxy traffic to the Diego Cell, but is the traffic making it there?
1. Ssh onto the Diego Cell where tcp_app is running and become root.
1. Use tcpdump to look at traffic destined for BACKEND_PORT.
 ```
tcpdump 'port BACKEND_PORT'
 ```
1. Run  `curl TCP_ROUTE:TCP_PORT` while tcpdump is watching.
If tcpdump is seeing packets, that indicates that the traffic is making it to the Diego Cell.

‚ùìAre the DNAT rules on the Diego Cell correct?
From the story _Route Propagation - Part 5 - DNAT Rules_ you learned that iptables rules redirect traffic that is sent to a Diego cell and backend port and send it to the overlay ip and app port. The same thing happens with TCP routes. Make sure that these DNAT rules are set up correctly.

1. Still on the Diego Cell, look at the DNAT rules.
 ```
iptables -S -t nat
 ```

1. Search through the rules for the one that includes the BACKEND_PORT for tcp_app. If it is set up correctly, then it should look something like this.

 ```
-A netin--b86c9487-2224-4264-47 -d DIEGO_CELL_IP/32 -p tcp -m tcp --dport BACKEND_PORT -j DNAT --to-destination OVERLAY_IP:8080
 ```

1. Compare the overlay IP in the DNAT rule with the overlay IP from the app's environment variables. They should match. If they match then this indicates that traffic should be correctly redirected to the correct app container.

‚ùìIs the traffic making it to the app container?
1. Using the link in the resources, start a bash session inside of the networking namespace of the app.
1. Run `tcpdump`.
1. Run  `curl TCP_ROUTE:TCP_PORT` while tcpdump is watching.
1. Ctl + C out of tcpdump in the app container. (Idk why, but tcpdump doesn't tail correctly when you are in a network namespace like this. So you need to kill it before you will see the output.)
If you see traffic, that means that the packets are making to inside of the app container.

‚ùìIs the traffic making it to the app process?
1. Still inside of the app's network namespace, look at the DNAT rules. Are there any rules here that are sending all tcp 8080 traffic to somewhere else?
1. Delete the bad DNAT rule and try curling the route again.
1. Success!

### Expected Result
Find the bug. Remove the offender and get this TCP route working!
Don't forget to redeploy to your old state afterwards.

## Resources
[How to get into a container's networking namespace as root](https://cloudfoundry.slack.com/archives/GFXGACQUB/p1554758849206400)

üôè _If this story needs to be updated: please, please, PLEASE submit a PR. Amelia will be eternally grateful. How? Go to [this repo](https://github.com/pivotal/cf-networking-program-onboarding). Search for the phrase you want to edit. Make the fix!_","tcp-routes,questions"
TCP Routes ‚áß,release,,tcp-routes
User Workflow: Route Services,feature,"## Assumptions
- You have a OSS CF deployed
- You have one [proxy](https://github.com/cloudfoundry/cf-networking-release/tree/develop/src/example-apps/proxy) app pushed and called appA
- You have one route mapped to appA called APP_A_ROUTE

## What

In the Route Propagation tack we talked about the flow of network traffic when an internet user tries to access your app. A very simplified version of this flow looked like this:
1. The traffic hits a load balancer in front of the CF Foundation
1. The load balancer sends it to one of the GoRouters
1. The GoRouter sends the traffic to the app

What is left out in that simplified flow, is that the app developer also has the option to introduce Route Services into this flow. From the [CF docs](https://docs.cloudfoundry.org/services/route-services.html): ""Cloud Foundry application developers may wish to apply transformation or processing to requests before they reach an application. Common examples of use cases include authentication, rate limiting, and caching services.""

When you add Route Services to the flow it looks like this:
1. The traffic hits a load balancer in front of the CF Foundation
1. The load balancer sends it to one of the GoRouters
1. **GoRouter sees there is a Route Service to apply**
1. **GoRouter appends a header to the traffic saying that the traffic has hit the GoRouter once and is being redirected to a Route Service**
1. **GoRouter redirects the traffic to the Route Service (which may or may not be an app inside of the same CF)**
1. **The Route Service applies a transformation to traffic**
1. **The Route Service redirects the traffic back to the load balancer**
1. **The load balancer sends it to one of the GoRouters**
1. **GoRouter sees the traffic has a header saying it has already been redirected to a Route Service**
1. The GoRouter sends the traffic to the app

![user provided route service](https://docs.cloudfoundry.org/services/images/route-services-user-provided.png)

In this story we are going to create a user-provided route service to rate limit traffic going to appA.

## How

üìù **Take control measurements**
1. Download boom, a benchmarking tool.
 ```
 go get github.com/rakyll/boom
 ```

1. Use boom to see what percentage of requests to APP_A_ROUTE return status 200.
 This command sends 100 requests, 10 concurrently with 10 QPS (queries per second)
 ```
 boom -n 100 -c 10 -q 10 http://APP_A_ROUTE
 ```

 You should see that all requests returned 200 OK.
 ```
 Status code distribution:
   [200]	100 responses
 ```

üìù **Use a Route Service**
0. Follow [these instructions](https://github.com/cloudfoundry-samples/ratelimit-service) to deploy a rate limiting Route Service and bind it to appA.
This example Route Service is old and you may get errors that it is running on an old go version. Fix it! Even better, submit a PR with your fix.

ü§î **Take measurements with Route Service**

1. Bind the Route Service to appA.
1. Make the Route Service seriously limit traffic.
1. Run the benchmarking tests.

### Expected Result
See that without the Route Service there is no rate limiting to appA. All responses should have status code 200.
See that with the Route Service there is rate limiting to appA. Some responses should have status code 200 and the rest should have code 429.
```
Status code distribution:
  [200]	2 responses
  [429]	98 responses
```

Delete the rate limiter app and unbind the route service before the next story.

## Resources
[CF docs - Route Services](https://docs.cloudfoundry.org/services/route-services.html)
[Rate Limiting Route Service](https://github.com/cloudfoundry-samples/ratelimit-service)

üôè _If this story needs to be updated: please, please, PLEASE submit a PR. Amelia will be eternally grateful. How? Go to [this repo](https://github.com/pivotal/cf-networking-program-onboarding). Search for the phrase you want to edit. Make the fix!_","route-services,user-workflow"
Exploiting Route Services,feature,"## Assumptions
- You have a OSS CF deployed
- You have one [proxy](https://github.com/cloudfoundry/cf-networking-release/tree/develop/src/example-apps/proxy) app pushed and called appA
- You have one route mapped to appA called APP_A_ROUTE
- You unbound the rate limiter route service from the previous story

## What

In the previous story when you created your own Route Service you ran a command that looked something like this...

`cf create-user-provided-service MY_SERVICE -r MY_SERVICE_URL`

The route MY_SERVICE_URL could be inside or outside of your Cloud Foundry. However, one takes precedence.
Let's say that MY_SERVICE_URL exists inside *and* outside of your Cloud Foundry. (Before a recent fix) GoRouter would
""hairpin"" and always default to the MY_SERVICE_URL that exists *inside* the Cloud Foundry.

Let's exploit this.

## How

ü§î **Pretend that you are an innocent dev**

1. You need to deploy to an older version of routing-release from before this attack vector was fixed. Deploy CF with [routing-release 0.186.0](https://bosh.io/releases/github.com/cloudfoundry-incubator/cf-routing-release?version=0.186.0).

1. Create a Route Service that sends all traffic to whitehouse.gov
 ```
 cf create-user-provided-service realwhitehouse -r https://www.whitehouse.gov/
 ```

1. Bind this new Route Service to your APP_A_ROUTE
 ```
cf bind-route-service DOMAIN  --hostname HOSTNAME realwhitehouse`
 ```

1. See that when you curl APP_A_ROUTE, you now just get www.whitehouse.gov (I don't know why you would want this. But it's an easy way to show this attack vector.)

üòà **Pretend that you are a malicious dev**

1. Push an app called fakewhitehouse using `--no-route`

1. Create the domain whitehouse.gov (`cf create-shared-domain --help`)

1. Map the route www.whitehouse.gov to the app fakewhitehouse
 ```
cf map-route fakewhitehouse whitehouse.gov --hostname www
 ```

1. In one terminal, watch the logs for the fakewhitehouseapp (`cf logs --help`)

1. In another terminal curl APP_A_ROUTE

### Expected Result
You should see in the fakewhitehouse app logs that traffic was redirected to fakewhitehouse
You should see by the response, that traffic was never sent to the real whitehouse.gov

‚ùìWhat happened?
‚ùìWhy is this really, really bad?
‚ùìHow could you exploit this on a shared deployment like PWS?

**Extra Credit**
1. Find the code in GoRouter that let this happen. Maybe start your search [here](https://github.com/cloudfoundry/gorouter/blob/f6879c04bac67c1e467f14b79496b9832869df91/proxy/round_tripper/proxy_round_tripper.go#L126-L196).

## Resources
[CF docs - Route Services](https://docs.cloudfoundry.org/services/route-services.html)
[Rate Limiting Route Service](https://github.com/cloudfoundry-samples/ratelimit-service)

üôè _If this story needs to be updated: please, please, PLEASE submit a PR. Amelia will be eternally grateful. How? Go to [this repo](https://github.com/pivotal/cf-networking-program-onboarding). Search for the phrase you want to edit. Make the fix!_","route-services,questions"
Route Services ‚áß,release,,route-services
Introduction to Interrupt Stories,feature,"üéâ Congratulations!
You made it through all of the main networking onboarding stories. Now, if you have time left over, it is time to put your skills to the test.
The next stories include actual interrupt questions (edited for formatting and spelling). It is your job to answer these questions.

üçÄ Good luck",interrupt
Interrupt: why don't ASGs work for Container to Container Networking?,feature,"## Interrupt

Hi folks,

What's the mechanism that prevents Diego hosted apps from hitting other diego-cells directly? I'm looking at the default ASG and it's not explicitly omitting my 10.0.x.y pcf-deployment network, yet i cannot curl from a cf-ssh session in an AI to another Diego cell?

```
name: default_security_group
         rules:
         - destination: 0.0.0.0-169.253.255.255
           protocol: all
         - destination: 169.255.0.0-255.255.255.255
           protocol: all
```

Note: I'm *very* pleased to see this restriction is in place but I thought we were depending on ASGs here. I've been asked by Voya to export some configuration for their compliance team to document that this isolation/control is in place. - but the default ASG is misleading because it, in theory, would allow a call to my diego cell running on 10.0.0.105 in my lab.

## Restate the question
_Sometimes interrupts misuse networking or CF terms. It's your job to get to the bottom of what they are asking for. In 2 sentences or less, restate their question. Put your interpretation below this text._

```
PUT YOUR INTERPRETATION HERE
```

## Your answer
_Now that we're on the same page about what is being asked, what is the answer? Provide your answer below this text._

```
PUT YOUR ANSWER HERE
```

üôè _If this story needs to be updated: please, please, PLEASE submit a PR. Amelia will be eternally grateful. How? Go to [this repo](https://github.com/pivotal/cf-networking-program-onboarding). Search for the phrase you want to edit. Make the fix!_",interrupt
"Interrupt: silk, VXLAN, and limitations",feature,"## Interrupt

Hello,

I've started reading about the container to container networking and I've noticed that the ""batteries included pack""
the Silk CNI plugin and the VXLAN Policy Agent use VXLAN.
In the [description](https://docs.cloudfoundry.org/concepts/understand-cf-networking.html ) of the VXLAN Policy agent it is written that the outbound traffic is tagged with the unique identifier of the source app using the VXLAN Group-Based Policy (GBP) header. Checking the [VXLAN GBP header documentation](https://tools.ietf.org/html/draft-smith-vxlan-group-policy-05) I've read that the ""Group Policy ID"" field is 16bit long which means 2^16= 64k unique source apps can be tagged. The VXLAN GBP header also has the VXLAN Network Identifier (VNI) field. I've also read in the [VXLAN RFC](https://tools.ietf.org/html/rfc7348) in section 4. VXLAN that ""Only VMs within the same VXLAN segment can communicate with each other. Each VXLAN segment is identified through a 24-bit segment ID, termed the 'VXLAN Network Identifier (VNI)'.""

Three things are not clear to me:
1. Does this setup use only one VXLAN? The docs talk about one overlay network to which all the Diego cells are connected.
2. Does the limitation that the VXLAN GBP header brings, means that only 64k unique source apps can be used for container to container networking per cf deployment?
3. Can we somehow overcome the limitation brought by the ""Group Policy ID"" field's size of 16bit in the VXLAN GBP by using the current setup and adding another VXLAN overlay or we have to re-implement all of the swappable components?

## Restate the question
_Sometimes interrupts misuse networking or CF terms. It's your job to get to the bottom of what they are asking for. Restate their question in a few sentences. Put your interpretation below this text._

```
PUT YOUR INTERPRETATION HERE
```

## Your answer
_Now that we're on the same page about what is being asked, what is the answer? Provide your answer below this text._

```
PUT YOUR ANSWER HERE
```

üôè _If this story needs to be updated: please, please, PLEASE submit a PR. Amelia will be eternally grateful. How? Go to [this repo](https://github.com/pivotal/cf-networking-program-onboarding). Search for the phrase you want to edit. Make the fix!_",interrupt
Interrupt: how to limit or block traffic,feature,"## Interrupt

Hello networking people, I wondered is there a way to limit outgoing traffic of an app? or blocking all udp traffic? how about rate limiting?

## Restate the question
_Sometimes interrupts misuse networking or CF terms. It's your job to get to the bottom of what they are asking for. Restate their question in a few sentences. Put your interpretation below this text._

```
PUT YOUR INTERPRETATION HERE
```

## Your answer
_Now that we're on the same page about what is being asked, what is the answer? Provide your answer below this text._

```
PUT YOUR ANSWER HERE
```

üôè _If this story needs to be updated: please, please, PLEASE submit a PR. Amelia will be eternally grateful. How? Go to [this repo](https://github.com/pivotal/cf-networking-program-onboarding). Search for the phrase you want to edit. Make the fix!_",interrupt
Interrupts ‚áß,release,,interrupt
Write a story!,feature,"What did we miss?

Write your own story about it and create a [PR](https://github.com/pivotal/cf-networking-program-onboarding/pulls).

Here are some topics:
- Routing to components
- Routing API
- Bosh DNS
- Routing with isolation segments
- HA proxy
- Istio
- CNI
- Linux sockets
- Search Domains
- Security (mTLS, certs, encryption, cert rotation)
- NSX-T
- PKS
- nmap
- wireshark
- ngrep",write-a-story
Create a story ‚áß,release,,write-a-story
