East/West What? Directional Networking Terms

## What

Network traffic can go in many directions, and there are many jargony way to refer to them. Let's define them.

**Ingress Traffic** is traffic that originates outside the local network that is transmitted to somewhere inside the local network. Remember ingress traffic is coming *in*.

**Egress Traffic** is traffic that originates inside the local network that is transmitted somewhere outside of the local network. Remember egress traffic is *e*xiting the local network.

```
 INGRESS TRAFFIC EXAMPLE          EGRESS TRAFFIC EXAMPLE

         +-----+                          +-----+
         |     |                          |     |
     +---+     +------+               +---+     +------+
   +-+                |             +-+                |
 +-+   The Internet   ++          +-+   The Internet   ++
 |                   +-+          |                   +-+
 +-------------------+            +-------------------+

               +                                ^
               |                                |
               |                                |
+----------------------+         +----------------------+
| Container    |       |         | Container    |       |
|              |       |         |              |       |
| +-------+    |       |         | +-------+    |       |
| |       |    |       |         | |       |    |       |
| | MyApp | <--+       |         | | MyApp | +--+       |
| |       |            |         | |       |            |
| +-------+            |         | +-------+            |
+----------------------+         +----------------------+





```

**North/South** traffic is any communication between two different networks.  Both Ingress and Egress are examples of North/South traffic.

**East/West** traffic is any communication within one network.

```
                  EAST/WEST TRAFFIC EXAMPLE

+-------------------------------------------------------------+
| My Local Network                                            |
|                                                             |
|                                                             |
|                                                             |
| +----------------------+         +----------------------+   |
| | Container1           |         | Container2           |   |
| |                      |         |                      |   |
| | +-------+            |         | +-------+            |   |
| | |       |            |         | |       |            |   |
| | | MyApp | +----------------->  | | MyApp |            |   |
| | |   1   |            |         | |   2   |            |   |
| | +-------+            |         | +-------+            |   |
| +----------------------+         +----------------------+   |
|                                                             |
+-------------------------------------------------------------+

```

## Questions

‚ùìHow would you use ingress, egress, north/south, and east/west to describe the following situations:
- You visit neopets in your browser.
- Your pair ssh-es onto your computer.
- You set up a local netcat server and send traffic to it from your terminal.

---

User Workflow: Application Security Groups

## Assumptions
- You have a CF deployed
- You have one [proxy](https://github.com/cloudfoundry/cf-networking-release/tree/develop/src/example-apps/proxy) app pushed and named appA

## What?
Application Security Groups (ASGs) are a collection of egress (outbound) rules that specify the protocols, ports, and IP ranges
where applications can send traffic. ASGs define rules that *allow* traffic. They are a whitelist, not a blacklist.
Diego Cells use these ASGs to filter and log outbound network traffic.

When applications are staging, there need to be ASGs permissive enough to allow download particular resources (for example: ruby gems for ruby apps).
After an application is running, devs often want the ASGs to be more restrictive and secure. To distinguish between these two different security
requirements, administrators can define different security groups for *staging* containers versus *running* containers.

To provide granular control when securing egress app traffic, an administrator can also assign security groups to apply across a CF deployment, or to specific spaces or orgs within a foundation.

### How?

üìù **Look at the defaults**
1. Look at all the security group CLI commands. The commands can be confusing; familiarize yourself with all of the commands available.
 ```
cf help -a | grep security-group
 ```
1. As admin view the list of security groups `cf security-groups`

 In most default OSS deployments there will be two ASGs: `public_networks` and `dns`. These default ASGs are bound (aka applied) to the entire foundation.

1. View the rules for the `public_networks` security group.
 ```
 cf security-group public_networks
 ```

The public_network ASG allows egress traffic to access the entire public internet, via every protocol.

ü§î **Using Running ASGs**
Because the wide open `public_networks` security group is bound to all running and staging contains for the entire foundation, your app should be able to connect to any website on the internet. Let's test this.
1. Ssh onto appA (`cf ssh --help`)
1. Curl www.neopets.com. Success!
1. Unbind the public_networks **running** security-group.
1. When you bind/unbind ASGs you will see this helpful tip `TIP: Changes will not apply to existing running applications until they are restarted.` So restart your app!
1. Ssh onto appA again
1. Curl www.neopets.com.

‚ùì What happened? Why did it fail?

ü§î **Using Staging ASGs**
1. Unbind the public_networks **staging** security-group.
1. Push a new app, and name it appB.

‚ùì What happened? Why did it fail?

**Reset your ASGs**
1. Rebind public_networks to both running and staging containers.

### Expected Result
When you have public_networks bound to all staging and running containers your apps can access the entire internet!
When public_networks is not bound to running containers then your running apps cannot access the internet.
When public_networks is not bound to staging containers, then the staging container is not able to access the internet to install godep (for go apps) and other staging requirements, so `cf push` will fail.

(If you're working with PCF Dev, you should see three security groups, one of which is named `all_pcfdev` and opens all egress traffic. Because of the `all_pcfdev` security group any other group would be redundant.)

## Resources
[Application Security Groups Documentation](https://docs.cloudfoundry.org/adminguide/app-sec-groups.html)
[Typical Application Security Groups](https://docs.cloudfoundry.org/adminguide/app-sec-groups.html#typical-groups)
["Taking Security to the Next Level‚ÄîApplication Security Groups" by Abby Kearns](https://blog.pivotal.io/pivotal-cloud-foundry/products/taking-security-to-the-next-level-application-security-groups)
["Making sense of Cloud Foundry security group declarations" by Sadique Ali](https://sdqali.in/blog/2015/05/21/making-sense-of-cloud-foundry-security-group-declarations/)

L: asgs
---

Anatomy of an Iptables Rule

## What
ASGs and c2c network policies are implemented using iptables rules. Think of iptables as a firewall implementation. (Iptables can do more than firewall things, but we have to start somewhere.)

All network traffic on linux machines is evaluated against the iptables rules written on the machine. To organize these rules, there are chains and tables. Chains have tables and tables have rules. Traffic hits different tables and chains depending on if the traffic is ingress, egress, or East/West.

Let's look at the anatomy of an iptables rule.

![iptables rule anatomy](https://deliveryimages.acm.org/10.1145/2070000/2062737/10822f2.png)

The example above can be translated as:
- (**table/chain**) For any traffic that is evaluated against the filter table on the INPUT chain...
- (**match**)...if that traffic is using the tcp protocol...
- (**match**)...and if that traffic is sending traffic to port 80...
- (**jump rule/target**) ... then ACCEPT that traffic.

Once a packet hits ACCEPT, then it stops evaluating in that table and chain. It would also stop if it hit a DROP or REJECT target.

## Resources
Deeper reading you might want later:
[iptables man page](http://ipset.netfilter.org/iptables.man.html)
[Aidan's iptables in CF ppt](https://docs.google.com/presentation/d/1qLkNu633yLHP5_S_OqOIIBETJpW3erk2QuGSVo71_oY/edit#slide=id.p)
[Julia Evans iptables basics](https://jvns.ca/blog/2017/06/07/iptables-basics/)

L: asgs
L: iptables
---

Iptables reading - a primer

## What
The next few stories will introduce you to iptables rules. Reading a little bit about them first will help a lot.

## How
1. Give the [iptables man page](http://ipset.netfilter.org/iptables.man.html) a skim. At least the description, targets, and tables sections.

1. Flip through [Aidan's "iptables in Cloud Foundry" powerpoint](https://docs.google.com/presentation/d/1qLkNu633yLHP5_S_OqOIIBETJpW3erk2QuGSVo71_oY/edit#slide=id.p)

L: asgs
L: iptables
---

Write your own iptables DROP rule in a docker container

## Assumptions
- You have the docker CLI installed

### What?
Experiment with writing your own iptables rules within the safety of your own docker container.

### How?

üìù **Get your docker container setup**
0. Run an ubuntu docker container and attach to it: `docker run --privileged -it ubuntu bin/bash`
0. Set up the docker container
    ```
    apt-get update
    apt-get install iptables
    apt-get install curl
    ```

üìù **What's the current state of the world?**
0. Look at the default iptables rules `iptables -S`.
    It should look like this:
    ```
    -P INPUT ACCEPT
    -P FORWARD ACCEPT
    -P OUTPUT ACCEPT
    ```
   Input, forward, and output are all names of chains. Currently there are no rules attached to these chains. What beautiful empty chains! This means that traffic is not being restricted by iptables.

0. See that traffic is not being restricted. `curl google.com`.  It works!

üìù **Make your own DROP rule**
Let's make a rule to DROP all traffic from the container so that the curl will fail.

0. Make your own custom chain.
 ```
 iptables -N drop-everything
 ```
0. Append a rule to your chain.
 ```
 iptables -A drop-everything -j DROP
 ```
0. View your handiwork. Oooooh. Ahhhhhhh.
 ```
 iptables -S
 ```
0. See if you can still `curl google.com`. What! The curl still works!
   That's because currently nothing is hitting your rule. You need to attach your custom chain to the INPUT, FORWARD, and/or OUTPUT chain in order for traffic to hit it.

    The INPUT, FORWARD, and OUTPUT chains are hit in different situations. (See diagram below)
    - The INPUT chain is hit by ingress traffic (remember, the traffic is coming *in*).
    - The FORWARD chain is hit by East/West traffic (remember... idk for this one).
    - The OUTPUT chain is hit by egress traffic (remember, the traffic is *e*xiting the container and going *out*).

   ![iptables chains and tables diagram](https://storage.googleapis.com/cf-networking-onboarding-images/iptables-tables-and-chains-diagram.png)

0. The request to google is egress traffic, so we want to attach out custom chain to the OUTPUT chain.
 ```
 iptables -A OUTPUT -j drop-everything
 ```

0. See if you can still `curl google.com`. You should see the error `Could not resolve host: google.com`.
0. Delete all of the rules and the chain that you created.
   Before you can delete the chain itself, you need to delete the rules attached to it using the `-D` flag.
   ```
iptables -D EITHER-INPUT-FORWARD-OR-OUTPUT -j drop-everything
iptables -D drop-everything -j DROP
   ```
   Then you can delete the chain itself using the `-X` flag
   ```
iptables -X drop-everything
   ```

Don't leave your docker container yet! You're going to need it in the next story!

### Expected Result

You should know how to...
- add/remove a iptables chain on a particular table
- add/remove a rule to an iptables chain


### Resources
[iptables man page](http://ipset.netfilter.org/iptables.man.html)
[Julia Evans iptables basics](https://jvns.ca/blog/2017/06/07/iptables-basics/)
[Aidan's iptables ppt](https://docs.google.com/presentation/d/1qLkNu633yLHP5_S_OqOIIBETJpW3erk2QuGSVo71_oY/edit#slide=id.p)
[iptables primer](https://danielmiessler.com/study/iptables/)

L: asgs
L: iptables
---

Write your own iptables firewall in a docker container

## What

Make a super basic firewall for your docker container. This (extremely practical) firewall will only let egress traffic exit if it is going to neopets.com.

## How

ü§î **Make your own rule**
0. Make your own chain.
0. Attach rule to that chain that accepts traffic if it is sent to ip 23.96.35.235 (neopets!) port 80 using tcp.
0. Attach a rule to that chain that drops all other traffic.
0. Add a jump rule to either the OUTPUT, FORWARD, or INPUT chains so that the traffic exiting the docker container will hit your custom chain.
0. Curl google.com. Does it fail?
0. Curl 23.96.35.235:80. Does it succeed?
0. Curl http://neopets.com. Does it fail or succeed? Why?
0. Delete all of the rules and chains that you created. (Do this after the extra credit, if you are so inclined.)

### Expected Result
Hopefully you realize by now that iptables rules are very powerful and very fun :D

‚ùìWhy didn't curling http://neopets.com work?

### Extra Credit
1. Use iptables rules to make it so you can curl neopets.com, but not google.com

## Resources
[iptables man page](http://ipset.netfilter.org/iptables.man.html)
[Julia Evans iptables basics](https://jvns.ca/blog/2017/06/07/iptables-basics/)
[Aidan's iptables ppt](https://docs.google.com/presentation/d/1qLkNu633yLHP5_S_OqOIIBETJpW3erk2QuGSVo71_oY/edit#slide=id.p)
[iptables primer](https://danielmiessler.com/study/iptables/)

L: asgs
L: iptables
---

ASGs and Iptables

In the previous story "User Workflow: Application Security Groups" you learned what ASGs *are*, but how are they implemented under the hood?
(Hint: iptables)

## Assumptions
- You have a CF deployed
- You have one [proxy](https://github.com/cloudfoundry/cf-networking-release/tree/develop/src/example-apps/proxy) app pushed and named appA (the fewer apps you have deployed the better)
- You have the public_networks security group bound to all running and staging containers

## What?
Information about ASGs are stored in CAPI's database. When a container create is triggered (for example by a cf push), CAPI passes ASG information along to Diego (container scheduler). Diego then passes the ASG information along to Garden (the container creator), which passes it along to the container networking components. After this long journey, the container networking components turn this ASG information into iptables rules on the Diego Cells.


Iptables rules are a series of rules that network packets match against to decide whether that traffic is allowed or not. This is one way firewalls can be implemented.
ASGs are only concerned with egress traffic from CF apps to something external to the CF foundation (usually the internet).

The iptables man page is extremely helpful as a reference! Consult it if you have any questions throughout this story.

Let's investigate what iptables rules are created for the public_networks ASG.

## How?

üìù **Find the iptables rule for the public_networks ASG**
1. Look at the ASG public_networks
 ```
 cf security-group public_networks
 ```
 Note which IP ranges are specified. Save these rules somewhere accessible for future reference.
1. Ssh onto the Diego Cell where appA is running and become root.
1. List all of the iptables rules on the filter table on the Diego Cell
 ```
 iptables -t filter -S
 ```

Yep. It's a lot. Take a deep breath. Read it line by line. I promise it will start to become comprehensible.

Remember those IP ranges that are in the public_networks security group?
If you search for one of them (ie. `0.0.0.0-9.255.255.255`) you should be able to find an iptables rule that looks something like this:

```
-A netout--772fbbd5-862a-4b3d-7 -m iprange --dst-range 0.0.0.0-9.255.255.255 -g netout--772fbbd5-862a-4--log
```

Copy the iptables rule that you found on the Diego Cell that looks like the line above. Paste it in the story below.
You will necessary to reference soon.

```
# Put your iptables rule...
# HERE
```

ü§î **Decipher the iptables rule for the public_networks ASG**
When you run `iptables -S` the iptables rules are displayed in the format that they were created in. For example, if you prepended `iptables` to the line above and ran (DON'T! this is hypothetical) `iptables -A netout--772fbbd5-862a-4b3d-7 -m iprange ...` it would add that iptables rule. 

With that in mind, use `iptables --help` to define what the following flags mean and record it below...

```
-A                                 ...
-m                                 ...
--dst-range                        ...
-g                                 ...
```

1. What is the name of the chain that the above iptables rule is appended to? Let's call this CHAIN-NAME.
1. What conditions need to be met for a packet to match this rule?
1. If packets meet the above conditions, what chain of rules will they jump to and evaluate against next? Let's call this JUMP-TO-CHAIN-NAME.

1. Look at the rules only in the chains from the questions above.
 ```
iptables --list CHAIN-NAME
iptables --list JUMP-TO-CHAIN-NAME
 ```

Packets stop matching against iptables rules when they reach either the ACCEPT target(let the packet flow through!), the DROP target (stop that packet in its tracks!), or the REJECT target(nicely tell the sender that this destination is not available to them) targets.

ü§î **Read iptables rules to predict behavior**
1. Pretend there is a packet trying to hit the IP 23.96.32.148 via tcp. Where will it hit ACCEPT or DROP?
1. Pretend there is a packet trying to hit the IP 172.20.0.3 via tcp. Where will it hit ACCEPT or DROP?
1. ssh onto your app and try to curl 23.96.32.148. Did it succeed or fail? Did it match your expectations?
1. ssh onto your app and try to curl 172.20.0.3. Did it succeed or fail? Did it match your expectations?


### Expected Result
You should be able to find the iptables rules for the public_networks and be able to follow the flow to either ACCEPT or DROP.

Iptables are hard! Hopefully they have been demystified a little bit.
Spend some extra time looking at all the iptables rules on a Diego Cell. Research what you don't understand. Ask lots of questions.

## Resources
**iptables**
[iptables man page](http://ipset.netfilter.org/iptables.man.html)
[Julia Evans iptables basics](https://jvns.ca/blog/2017/06/07/iptables-basics/)
[Aidan's iptables ppt](https://docs.google.com/presentation/d/1qLkNu633yLHP5_S_OqOIIBETJpW3erk2QuGSVo71_oY/edit#slide=id.p)
[iptables primer](https://danielmiessler.com/study/iptables/)

**ASGs**
[Application Security Groups Documentation](https://docs.cloudfoundry.org/adminguide/app-sec-groups.html)
[Typical Application Security Groups](https://docs.cloudfoundry.org/adminguide/app-sec-groups.html#typical-groups)
["Taking Security to the Next Level‚ÄîApplication Security Groups" by Abby Kearns](https://blog.pivotal.io/pivotal-cloud-foundry/products/taking-security-to-the-next-level-application-security-groups)
["Making sense of Cloud Foundry security group declarations" by Sadique Ali](https://sdqali.in/blog/2015/05/21/making-sense-of-cloud-foundry-security-group-declarations/)

L: asgs
L: iptables
---

[RELEASE] Application Security Groups (ASGs) ‚áß
L: asgs
